[{"content":"","date":"25 December 2025","externalUrl":null,"permalink":"/tags/hook/","section":"Tags","summary":"","title":"Hook","type":"tags"},{"content":"","date":"25 December 2025","externalUrl":null,"permalink":"/tags/mac/","section":"Tags","summary":"","title":"Mac","type":"tags"},{"content":" 本文地址：https://blog.yinmo19.top/posts/hook_mac_binary/\nYinMo 不对您复现本文产生的任何问题负责，请您搞清楚您正在做什么。您可能需要一些计算机常识与 C/Rust 基础来理解下面的文字。\n另外我习惯在代码中写英文注释，如果您不能阅读中文也无需担心，网页翻译一般能够正确的处理正文，而代码块中的注释您应该也能直接读懂（虽然我的英文水平可能会闹点笑话，见谅）\n在试图 hook 一个 MacOS 上的函数的时候，我找遍了全网都没有一个简明的可以直接使用的最小案例，这让我非常难受。看上去最能成功的一个也需要在 xcode 里面创建一个工程，选择 library 然后使用 obj-c 来写。\n我并不是不喜欢 obj-c, 但是按照我的观念我需要的是一个比较底层的语言，比如 c 或者 rust 来进行操作系统级别的操作。按照目前的目标，应该是直接写一段最简单的 C/Rust 代码就能直接 hook 一个任意二进制中的函数。为了实现这个目标，我们需要一个工具叫做 insert_dylib(https://github.com/tyilo/insert_dylib)。它可以实现一个比较酷炫的动态链接库注入，而无需我们去手动使用\nDYLD_INSERT_LIBRARIES=patch.dylib ./main 这样的运行方式。当然除了上面两个，我们还可以使用 optool，当然他们的使用方式有所不同，代码方面也是。\n准备工作 # 即使我们有 insert_dylib 这样的工具，我们也不能期望随便写一个动态链接库实现一个同名函数就能自动 hook，我们需要一些框架来帮我完成根据偏移量的注入、或者直接根据符号名称的实现替换。这里经过我几个小时的调研，最后选用了一个依赖看上去最少的框架 dobby。下载下来之后发现根本没有文档，网上的案例也鲜有 MacOS aarch64 的（可能是因为 M 系列芯片出来不久？）。似乎有人做了一个整合，叫做 dylib_dobby_hook。 但是这个居然是一个 xcode 工程。\nBro\u0026hellip;\u0026hellip; What I f**king NEED is just a header and dylib and a simple C file to build a shared dynamic library, OK? (Just kidding, a poor imitation of Tsoding ,ref: tsoding\u0026rsquo;s complains on ffi of Swift and C)\nanyway，我们还是根据唯一的 doc，也就是编译那一步，走 cmake .. \u0026amp;\u0026amp; make -j4 的操作把 dylib 和 .a 文件构建出来吧。\nhook # 由于 aslr，每次运行的基址都不一样，所以我们需要用一个 dyld 提供的函数 _dyld_get_image_vmaddr_slide 来获得对应 image 的基址。因为我们默认 hook 的都是最开始加载进去的那个，所以 index 直接写 0 就可以了。\n我们先从偏移量开始 hook。写一个最简单的 C 文件\n#include \u0026lt;stdio.h\u0026gt; int weird_add(int a, int b) { return a + 2 * b; } int weird_sub(int a, int b) { return a - 2 * b; } int weird_mul(int a, int b) { return a * 2 * b; } int weird_div(int a, int b) { return a / 2 * b; } int weird_mod(int a, int b) { return a % 2 * b; } int main() { printf(\u0026#34;%d\\n\u0026#34;, weird_add(4, 9)); printf(\u0026#34;%d\\n\u0026#34;, weird_div(10, 2)); return 0; } 目前我们的输出应该是这样的\ncc main.c -o main \u0026amp;\u0026amp; ./main 22 10 不进行任何优化，或者记得在编译选项中加入 -fno-inline，因为不加这个参数优化后函数会直接内联到主函数中我们就没法 hook 函数调用了。接下来我们通过 objdump 来看看我们需要的内容\n; \u0026gt; objdump -d main ; main:\tfile format mach-o arm64 ; Disassembly of section __TEXT,__text: 0000000100000460 \u0026lt;_weird_add\u0026gt;: 100000460: d10043ff sub\tsp, sp, #0x10 100000464: b9000fe0 str\tw0, [sp, #0xc] 100000468: b9000be1 str\tw1, [sp, #0x8] 10000046c: b9400fe8 ldr\tw8, [sp, #0xc] 100000470: b9400bea ldr\tw10, [sp, #0x8] 100000474: 52800049 mov\tw9, #0x2 ; =2 100000478: 1b0a7d29 mul\tw9, w9, w10 10000047c: 0b090100 add\tw0, w8, w9 100000480: 910043ff add\tsp, sp, #0x10 100000484: d65f03c0 ret 000000010000052c \u0026lt;_main\u0026gt;: ; ... prev too long, wrapped. 100000544: 52800080 mov\tw0, #0x4 ; =4 100000548: 52800121 mov\tw1, #0x9 ; =9 10000054c: 97ffffc5 bl\t0x100000460 \u0026lt;_weird_add\u0026gt; 100000550: 910003e9 mov\tx9, sp 100000554: aa0003e8 mov\tx8, x0 100000558: f9000128 str\tx8, [x9] 10000055c: 90000000 adrp\tx0, 0x100000000 \u0026lt;_printf+0x100000000\u0026gt; 100000560: 9116b000 add\tx0, x0, #0x5ac 100000564: f9000be0 str\tx0, [sp, #0x10] 100000568: 9400000e bl\t0x1000005a0 \u0026lt;_printf+0x1000005a0\u0026gt; 10000056c: 52800140 mov\tw0, #0xa ; =10 100000570: 52800041 mov\tw1, #0x2 ; =2 100000574: 97ffffd8 bl\t0x1000004d4 \u0026lt;_weird_div\u0026gt; 可以看到实际上调用的地址是 0x100000460，所以我们实际上应该 hook 的指针应该是\n_dyld_get_image_vmaddr_slide(0) + 0x100000460 既然这样，我们打开一个新的目录，然后将之前构建好的 libdobby.dylib 和 dobby.h 文件放入这个文件夹，然后随便打开一个新的 C file，这里我叫 patch.c\n#include \u0026#34;dobby.h\u0026#34; #include \u0026lt;mach-o/dyld.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; int real_add(int a, int b) { printf(\u0026#34;Calling replacement function!\\n\u0026#34;); return a + b; } int real_div(int a, int b) { printf(\u0026#34;Calling real div function!\\n\u0026#34;); return a / b; } __attribute__((constructor)) static void ctor(void) { intptr_t weird_add_ptr = _dyld_get_image_vmaddr_slide(0) + 0x100000460; intptr_t weird_div_ptr = (intptr_t)DobbySymbolResolver(\u0026#34;\u0026#34;, \u0026#34;weird_div\u0026#34;); DobbyHook((void *)weird_add_ptr, real_add, (void **)\u0026amp;weird_add_ptr); DobbyHook((void *)weird_div_ptr, real_div, (void **)\u0026amp;weird_div_ptr); } 我们需要使用 constructor 来让这个 dylib 在刚加载进去就 hook 掉对应的地址，具体实现由 DobbyHook 来完成。就这么短。但是接下来的重点来了。如果我们只是当成正常的 shared dynamic library 来构建，会一直失败，遇到什么 Rpath not found 之类的错误。这里我们需要用到 install_name_tool 来更改一些奇妙的加载路径。\ncc -shared -o patch.dylib patch.c ./libdobby.dylib -O2 install_name_tool -change @rpath/libdobby.dylib @loader_path/libdobby.dylib patch.dylib insert_dylib @loader_path/patch.dylib main main_patched --all-yes 然后我们再运行\n\u0026gt; ./main_patched Calling replacement function! 13 Calling real div function! 5 就能看到已经被 hack 掉的第一个函数。我不禁吐槽，这么一个最基础的 demo 为什么不会出现在搜索引擎的前几条，最后还是自己摸出来的？\nrust 篇 # 由于我日常写 rust 更加熟练一些，而且 dobby 也有 rust binding，所以我们也可以试一下。但是这个 bining 非常坑，上一次更新还是几年前，构建都过不去，而且文档也是几乎如同啥也没写。最基础的 demo 也没有。\n首先，由于第一个 pr，这个项目本身 link 的 dobby c dylib 是 ios 版本的，所以我 fork 了一份，将其更改到 Mac 的版本，并且由于新版本的 xcode 工具链已经抛弃了使用 -libstdc++ 而是实际使用 -libc++ 所以我们还需要更改 build.rs 里面的编译命令。\ndobby-rs https://github.com/YinMo19/dobby-rs dobby-sys https://github.com/YinMo19/dobby-sys 我认为我需要改的更优雅一些，再考虑去给原作者提一个 pr（不知道他是否还接受维护），总之目前我自己的这个版本 我自己 是可用的。（说实话改了好多，我换掉了旧的 dylib（只更新了 MacOS，linux 还没换），更新了 header，然后重跑了 bindgen，还添加了一个新函数 instrument，虽然我觉得我设计 api 设计的并不好)\n总之如果你现在想要复现我做的事情，你可以试试使用我的这个 dobby-rs crate。开一个 lib 的 rust crate，然后写入\n[package] name = \u0026#34;dobby_test\u0026#34; version = \u0026#34;0.1.0\u0026#34; edition = \u0026#34;2024\u0026#34; [lib] crate-type = [\u0026#34;cdylib\u0026#34;] [dependencies] dobby-rs = { git = \u0026#34;https://github.com/YinMo19/dobby-rs.git\u0026#34; } [profile.release] opt-level = 3 strip = true lto = true 接下来我们就可以开始 hook 了。\nuse dobby_rs::{Address, hook, resolve_symbol}; unsafe extern \u0026#34;C\u0026#34; { fn _dyld_get_image_vmaddr_slide(image_index: u32) -\u0026gt; isize; } extern \u0026#34;C\u0026#34; fn real_add(a: u64, b: u64) -\u0026gt; u64 { println!(\u0026#34;[Rust Hook] Intercepted a: {}, b: {}\u0026#34;, a, b); a + b } extern \u0026#34;C\u0026#34; fn real_div(a: i32, b: i32) -\u0026gt; i32 { println!(\u0026#34;[Rust Hook] Intercepted a: {}, b: {}\u0026#34;, a, b); a / b } #[unsafe(link_section = \u0026#34;__DATA,__mod_init_func\u0026#34;)] #[unsafe(no_mangle)] pub static INIT: extern \u0026#34;C\u0026#34; fn() = ctor; extern \u0026#34;C\u0026#34; fn ctor() { let target_addr = (0x100000460 + unsafe { _dyld_get_image_vmaddr_slide(0) }) as Address; let weird_div = resolve_symbol(\u0026#34;\u0026#34;, \u0026#34;weird_div\u0026#34;).unwrap(); unsafe { hook(target_addr, real_add as Address).unwrap(); hook(weird_div, real_div as Address).unwrap(); } } 这里我们展示了两种 hook 办法，一种是基于 offset，另外一个直接根据 symbol，能够实现更加简单的 hook 办法。代码很短，主要是从 C 导入 dyld 那个函数，解析地址，然后 hook 并导出为实际的 hook 方法。rust 构建的 dylib 可以直接 insert_dylib\ncargo build --release insert_dylib target/release/libdobby_test.dylib main --all-yes ./main_patched [Rust Hook] Intercepted a: 4, b: 9 13 [Rust Hook] Intercepted a: 10, b: 2 5 就是这样，有了这样的方法我们可以简单的去做任何事情，包括hook 一个函数改一些汇编，给一个 binary 实现新功能，hack 一些函数等等。\npatch Code # 是的，我们还可以实现指令级别的修改。由于年久失修，总之又是一番改库，现在这个功能也能用了。参考我的上一篇 blog，是迫害某游戏的，我们使用了直接原地 patch 的操作，of course it works, 但是我们依然可以通过非侵入式的方式修改。\n还是一样需要准备好新的汇编的二进制，是小端序的 [u8] 序列，当然如果你愿意你也可以直接通过一个 0x0d000721 这样的 op code 然后直接 to_le_bytes 来完成，虽然我不是很推荐。然后我们直接使用\npub unsafe fn patch_code(addr: Address, code: \u0026amp;[u8]) -\u0026gt; Result\u0026lt;(), DobbyMemoryOperationError\u0026gt; 这个函数来实现 patch。用起来很简单，指定好我们需要 patch 的地址，然后把小端序的二进制准备好就可以直接替换掉对应的位置了。亲测好用。\n但是如果我只是需要 patch code 的话，随便找个 hex editor 直接改不就完事了吗\u0026hellip; 顶多重签名一下就能跑了？\n或许有什么深意没有 get 到。\n加载 image 的顺序 # 然后最后就是关于 MacOS 上 insert_dylib 的一些使用上的指南。dobby 实际上是将原本的二进制里面的那个函数实现进行了替换，无论原本是做什么，现在就是在这个函数里面调用我们新定义的函数。insert_dylib 做的事情是侵入式的，也就是整个二进制是作为第一个加载进内存的 image，因此我们使用 _dyld_get_image_vmaddr_slide(0) 来进行地址计算。\n但是如果我们使用的是非侵入式方法，例如 DYLD_INSERT_LIBRARIES=xxx.dylib ./a_binary 这样的，那么实际上主二进制是作为第二个加载进去的 image。所以我们需要使用 _dyld_get_image_vmaddr_slide(1)。当然如果使用的是 symbol resolve 方法就不需要考虑这些了。这里我们可以通过下面的代码来确认这个行为。\nextern \u0026#34;C\u0026#34; fn ctor() { let weird_add_offset_0 = (0x100000460 + unsafe { _dyld_get_image_vmaddr_slide(0) }) as Address; let weird_add_offset_1 = (0x100000460 + unsafe { _dyld_get_image_vmaddr_slide(1) }) as Address; let weird_add_sym = resolve_symbol(\u0026#34;\u0026#34;, \u0026#34;weird_add\u0026#34;).unwrap(); println!(\u0026#34;using image 0: {weird_add_offset_0:?}, using 1: {weird_add_offset_1:?}\u0026#34;); println!(\u0026#34;correct answer: {weird_add_sym:?}\u0026#34;); } 我们看看运行结果\n\u0026gt; DYLD_INSERT_LIBRARIES=target/release/libdobby_test.dylib ./main using image 0: 0x204198460, using 1: 0x104140460 correct answer: 0x104140460 22 10 \u0026gt; insert_dylib target/release/libdobby_test.dylib main --all-yes \u0026amp;\u0026amp; codesign -f -s - main_patched \u0026amp;\u0026amp; ./main_patched main_patched already exists. Overwrite it? [y/n] y LC_CODE_SIGNATURE load command found. Remove it? [y/n] y It doesn\u0026#39;t seem like there is enough empty space. Continue anyway? [y/n] y Added LC_LOAD_DYLIB to main_patched using image 0: 0x102748460, using 1: 0x2027a4460 correct answer: 0x102748460 [1] 96417 illegal hardware instruction ./main_patched 可以看到非侵入式的时候 weird_add 与使用第二个 image 是一样的，而侵入式方法则与第一个一样。\nInstrument hack # 除此之外，在原本的 dobby-rs binding 没有 pub 出来的还有一个 instrument 函数，这个函数可以完成更加有意思的任务。考虑这样一个场景，我们需要在一个不是函数调用的任意地址，我们想要 hook 这个地方，查看当前所有寄存器以及临时变量等等，我们应该怎么做？\ndobby 框架提供了一个 instrument 的函数，它可以在那条指令插入一个函数调用，直接调用我们新定义的一个 callback 函数，并在调用这个函数前保存好所有的临时变量和寄存器。在这函数执行完返回的时候会恢复所有寄存器状态，并在返回前执行被我们替换为调用 callback 的那个地址的指令。\n0x1000004e0 mov x8, x9 ; original ; dobby change it to 0x1000004e0 b \u0026lt;the callback function\u0026#39;s offset\u0026gt; ; \u0026lt;the callback function\u0026#39;s offset\u0026gt;: ; save all the reg\u0026#39;s state ; do what we do in our definition of callback ; restore the regs mov x8, x9 ret 这里我们用一个案例来看看这个 hook 的用法。我们模拟一堆很复杂的位运算来当成校验 license\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; int check_license(int input_key) { uint32_t transformed_key = input_key; transformed_key ^= 0x55AA55AA; transformed_key = (transformed_key \u0026lt;\u0026lt; 7) | (transformed_key \u0026gt;\u0026gt; 25); // a lot of calulation! wrapped if (transformed_key == 0xDEADC0DE) { return 1; } return 0; } int main() { int key; printf(\u0026#34;Enter License Key: \u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;key); if (check_license(key)) { printf(\u0026#34;Access Granted!\\n\u0026#34;); } else { printf(\u0026#34;Access Denied!\\n\u0026#34;); } return 0; } 编译，然后我们可以看到\n0000000100000460 \u0026lt;_check_license\u0026gt;: 100000460: 528ab548 mov\tw8, #0x55aa ; =21930 100000464: 72aab548 movk\tw8, #0x55aa, lsl #16 100000468: 4a080008 eor\tw8, w0, w8 10000046c: 13886508 ror\tw8, w8, #0x19 ; alot of calulation! wrapped. ; w0 = 1 if w8 == w9 else 0 1000004e4: 6b09011f cmp\tw8, w9 1000004e8: 1a9f17e0 cset\tw0, eq 1000004ec: d65f03c0 ret 这里我们可以看到，最后我们对 w8, w9进行比较，所以我们可能就会想要在 0x1000004e4 这里看看 w8 和 w9 的值，顺便把他俩改成一样的。\nextern \u0026#34;C\u0026#34; fn callback(addr: Address, ctx: *mut DobbyRegisterContext) { println!(\u0026#34;Address now is {addr:?}\u0026#34;); println!( \u0026#34;original w8 is {:x} and w9 is {:x}\u0026#34;, unsafe { (*ctx).general.regs.x8 }, unsafe { (*ctx).general.regs.x9 } ); unsafe { (*ctx).general.regs.x8 = (*ctx).general.regs.x9 } println!( \u0026#34;Now w8 is {:x} and w9 is {:x}\u0026#34;, unsafe { (*ctx).general.regs.x8 }, unsafe { (*ctx).general.regs.x9 } ); } extern \u0026#34;C\u0026#34; fn ctor() { let license_original = unsafe { _dyld_get_image_vmaddr_slide(1) + 0x1000004e4 }; unsafe { instrument(license_original as Address, callback).unwrap(); } } 事实上就是如此，我们只需要找到偏移量，然后使用 instrument 函数注入一个 callback 函数，这个 callback 函数接受两个参数，分别是 hook 的地址和目前的状态上下文。其中状态上下文包含了所有寄存器状态，例如我们这里可以打印查看寄存器状态，并直接修改这个状态。\n\u0026gt; DYLD_INSERT_LIBRARIES=target/release/libdobby_test.dylib ./license Enter License Key: aoscinasoicnsaoci Address now is 0x1004984e4 original w8 is a7a79c65 and w9 is deadc0de Now w8 is deadc0de and w9 is deadc0de Access Granted! 有了这个功能我们就可以直接给二进制打日志了。我们直接找到想要看看运行时日志的地方，就可以直接打印出来想看的东西。这个功能感觉非常强大，但是也有一些限制。例如此时我们无法使用 insert_dylib 直接侵入式持久化 hook，经常遇到 [1] 48351 illegal hardware instruction ./license_patched。并不太清楚是怎么回事，我查看更改之后的二进制发现确实是 patch 出了一些奇怪的指令，所以可能是工具的问题？\n另外上下文保存的信息是寄存器，例如 DobbyRegisterContext.general下面的类型是\n#[repr(C)] #[derive(Copy, Clone)] pub union DobbyRegisterContext__bindgen_ty_1 { pub x: [u64; 29usize], pub regs: DobbyRegisterContext__bindgen_ty_1__bindgen_ty_1, } 一个 union，也就是说 regs.x0 其实等价于 x[0]，所以如果需要大批量打印可以考虑直接使用 x。另外还可以查看浮点数寄存器，fp，sp 之类的。但是浮点寄存器似乎有一些限制，dobby 源码的头文件原话是\nfor Arm64, can\u0026rsquo;t access q8 - q31, unless you enable full floating-point register pack.\nAppendix # Hook on Linux # 事实上我们在 hook 的时候最重要的是，在原本的二进制的 main 运行前先把我们的实现注入，我们上文提到我们使用的是有 constructor 特性的这个 ctor 函数，这个函数在为了实现在 binary 前的提前调用，在 C 里面看上去平平无奇，但是在 rust 代码里面因为没有原生的\n__attribute__((constructor)) static void ctor(void) { } 这样的方法可供调用，因此我们实际上是通过指定了 link_section 这样的编译选项来实现的。注意，这个编译选项是平台相关的，在 mac 上我们使用的是\n#[unsafe(link_section = \u0026#34;__DATA,__mod_init_func\u0026#34;)] #[unsafe(no_mangle)] pub static INIT: extern \u0026#34;C\u0026#34; fn() = ctor; 而在 linux 上我们需要使用\n#[unsafe(link_section = \u0026#34;.init_array\u0026#34;)] #[unsafe(no_mangle)] pub static INIT: extern \u0026#34;C\u0026#34; fn() = ctor; 如果你不想手动处理这个，你可以使用 ctor 这个 crate，他有一个宏可以直接按照平台帮你处理好这个事。\n除此之外，我们在 linux 上想要获取 aslr 的基址，由于 linux 上没有类似于 macos 上有 mach-o/dyld这样提供有 _dyld_get_image_vmaddr_slide 函数的库，所以我们需要使用 dlopen 之类的函数来获取程序运行的基址。\n// src/base_addr.rs // // add libc to your cargo.toml use libc::{c_char, c_void}; #[repr(C)] pub struct LinkMap { pub l_addr: usize, pub l_name: *mut c_char, pub l_ld: *mut c_void, pub l_next: *mut LinkMap, pub l_prev: *mut LinkMap, } const RTLD_DI_LINKMAP: i32 = 2; pub fn get_main_base_address() -\u0026gt; usize { unsafe { let handle = libc::dlopen(std::ptr::null(), libc::RTLD_LAZY); if handle.is_null() { return 0; } let mut ptr: *mut LinkMap = std::ptr::null_mut(); libc::dlinfo(handle, RTLD_DI_LINKMAP, \u0026amp;mut ptr as *mut _ as *mut c_void); let base_addr = (*ptr).l_addr; libc::dlclose(handle); base_addr } } 由于 libc 这个库没有给出 dlopen 函数的返回值类型以及 dlinfo 函数的参数（在 linux 上实际上是一个 link_map），所以我们需要自己去定义这样的结构体类型 (注意需要满足 C ABI，repr(C)）将返回的这个 *mut c_void 指针进行一个类型转换（这里只需要 as 就可以了）才能正常的获取到我们需要的信息。\nextern \u0026#34;C\u0026#34; fn ctor() { unsafe { hook( // analyse the binary and get the original function\u0026#39;s Address // in this case is 0x12c9. (get_main_base_address() + 0x12c9) as Address, // NOTE: define the replace function before. replace as Address, ) .unwrap(); } } 这样就能完成一个我们想要的 hook。\nlinux 上编译获得的不是 dylib 文件而是 so 文件，虽然他们后缀名不同，但是实际上都是 dynamic link library（所以 windows 上叫 dll），所以用法一样吗？MacOS 我们介绍了\n# method 1, no need to change the original binary file DYLD_INSERT_LIBRARIES=target/release/libdobby_test.dylib ./license # method 2 and 3, need patch the original file. insert_dylib target/release/libdobby_test.dylib license --all-yes optool install -c load -p @executable_path/target/release/libdobby_test.dylib -t license 这样的三个方法来注入，而 linux 上我们没有 insert_dylib 也没有 optool， 但是第一种方法改个名字我们就可以继续使用\nLD_PRELOAD=./target/release/libcamellia_hook.so ./main 是的，虽然名字不太一样，但是在 linux 上其实 LD_PRELOAD 就差不多等价于 mac 上的 DYLD_INSERT_LIBRARIES。\nHook cpp binary # 这里介绍的是 Cpp 的 binary hook，但是实际上想要介绍的实际上是对于除了 C 以外的语言的一些经验。每个语言都有自己的一些特殊的数据结构，例如 rust 有 Vec，cpp 则是 vector。虽然他们看上去都差不多，但是底层的实现肯定不可能一样。因此如果要 hook 这些语言相关的特殊数据结构，你就需要先搞懂这些语言底层是怎么实现这些数据结构的，以及这些数据结构是怎么样进行内存管理以及传参的。\n最简单的案例就是传递引用的指针，这样 hook 的时候我们拿到的就是一个对应数据结构的指针，然后我们在 hook 的语言中定义对应的数据结构，然后根据指针拿到值之后进行对应的处理，按照原本的返回值类型返回相应的内容就可以了。这似乎并不困难，但是实际很多情况我们会遇到传值的函数，这里就需要注意了。这里我们就使用 cpp 和 rust 之间的 hook 和 function call 来看看这里面的一些细节。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; vector\u0026lt;int\u0026gt; double_vec(vector\u0026lt;int\u0026gt; a) { for (size_t i = 0; i \u0026lt; a.size(); i++) { a[i] *= 2; } return a; } int main() { vector\u0026lt;int\u0026gt; a = double_vec(vector\u0026lt;int\u0026gt;{1, 2, 3, 4, 2}); for (size_t i = 0; i \u0026lt; 5; i++) { cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; endl; } return 0; } 这是我们打算 hook 的函数。\nc++ main.cpp -o main -O2 -fno-inline \u0026amp;\u0026amp; ./main 2 4 6 8 4 构建编译然后跑。ok，所有都在预期内。（这里的 c++ 在不同操作系统有不同实现，mac 上实际上是 clang++，cc 是 clang，另外在 mac 上其实 gcc 和 cc 和 clang 都是同一个东西，如果想在 mac 上使用真正的 gcc 请在 brew 里面下载 gcc。另外 brew 也可以装 llvm，虽然并不建议）\n; \u0026gt; objdump -d main | grep double_vec --context 10 ; Some irrelevant content has been omitted. 0000000000001410 \u0026lt;_Z10double_vecSt6vectorIiSaIiEE\u0026gt;: 1410:\tf3 0f 1e fa endbr64 1414:\t41 54 push %r12 1416:\t49 89 f0 mov %rsi,%r8 1419:\t49 89 fc mov %rdi,%r12 141c:\t48 8b 3e mov (%rsi),%rdi 141f:\t48 8b 76 08 mov 0x8(%rsi),%rsi 1423:\t31 d2 xor %edx,%edx 1425:\te8 d6 ff ff ff call 1400 \u0026lt;_ZNKSt6vectorIiSaIiEE4sizeEv.isra.0\u0026gt; 142a:\t48 89 c1 mov %rax,%rcx 142d:\teb 0f jmp 143e \u0026lt;_Z10double_vecSt6vectorIiSaIiEE+0x2e\u0026gt; 142f:\t90 nop ; ... cpp 的编译结果有一些混淆，但是 double_vec 的字样依然还在，也就是说并没有 strip，我们依然可以使用_Z10double_vecSt6vectorIiSaIiEE 这个名字进行 symbol hook，当然这里我们不打算这样干，直接用偏移量 0x1410 即可。\n好了，接下来来到最困难的时候了。我们会发现，每个平台上 cpp 编译器对 vec 的函数调用行为还是不一样的。如果详细展开我可以再写一篇 blog，所以这里我只演示一个最简单案例。这里我们看到的是 x86 操作系统，基于\n\u0026gt; cc --version cc (Ubuntu 11.4.0-1ubuntu1~22.04.2) 11.4.0 Copyright (C) 2021 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 这个编译器版本的行为。（这是在我 mac 上的一个 orbstack 创建的虚拟机，如果你也想试试，但愿这可以成功复现。）\nC++的 Vector 实现是\n#[repr(C)] #[derive(Debug)] pub struct CppVector\u0026lt;T\u0026gt; { pub start: *mut T, pub finish: *mut T, pub end_of_storage: *mut T, } 这样的，因此我们先创建一个 cxx_hook.rs 文件创建一些胶水代码。\n// please paste struct definition before here. impl\u0026lt;T\u0026gt; CppVector\u0026lt;T\u0026gt; { pub fn len(\u0026amp;self) -\u0026gt; usize { (self.finish as usize - self.start as usize) / std::mem::size_of::\u0026lt;T\u0026gt;() } pub fn as_slice(\u0026amp;self) -\u0026gt; \u0026amp;[T] { unsafe { std::slice::from_raw_parts(self.start, self.len()) } } pub fn from_vec(mut v: Vec\u0026lt;T\u0026gt;) -\u0026gt; Self { v.shrink_to_fit(); let len = v.len(); let cap = v.capacity(); let ptr = v.as_mut_ptr(); std::mem::forget(v); unsafe { Self { start: ptr, finish: ptr.add(len), end_of_storage: ptr.add(cap), } } } } 这里主要构建了几个常用的方法，第一个是获取长度，第二个是从 Cpp 的 Vector 转换为 rust 的类型，第三个是从 rust 的 Vec 转换到 Cpp 的 Vec。这里需要注意的是内存管理，由于我们期望的是从 rust 创建一个对象，并传递到 Cpp 接下来的内容，因此我们必须让 rust 的编译器忘掉这块内存，以期让 cpp 的编译器自己去 drop 掉函数返回的这块内容。\nhook 的第一步是从 rust 里面调用 Cpp 的函数。我们上面给出的那个函数需要传递一个 Vector 给 cpp，它会将这个 Vector 内的每个数字乘二。\nextern \u0026#34;C\u0026#34; fn ctor() { unsafe { let ori: fn(CppVector\u0026lt;i32\u0026gt;) -\u0026gt; CppVector\u0026lt;i32\u0026gt; = // get_main_base_address is define before, // dont forget to add it. transmute((get_main_base_address() + 0x1410) as Address); println!( \u0026#34;ori: {:?}\u0026#34;, ori(CppVector::from_vec((1..10).map(|i| i * i).collect())).as_slice() ); } } 所以我们先获取到这个函数的地址（当然你可以使用 symbol resolve，但是为了应付 symbol stripped 的情况，我这里还是使用偏移量。\n\u0026gt; LD_PRELOAD=./target/release/libcamellia_hook.so ./main ori: [2, 8, 18, 32, 50, 72, 98, 128, 162] 2 4 6 8 4 非常好，居然成功了。（说起来我正在写一个 hook cpp 写的奇怪 camellia 加密实现，所以这些内容其实是 hook 这个实现的一些实验性代码，所以如果你需要复现这些内容请自行修改二进制路径）\n但是接下来才是大头，你会发现如果你只是正常的写一个 fn(CppVector\u0026lt;i32\u0026gt;) -\u0026gt; CppVector\u0026lt;i32\u0026gt; 这样签名的 replace function 你必然失败。究其原因还是看汇编源码\n0000000000001410 \u0026lt;_Z10double_vecSt6vectorIiSaIiEE\u0026gt;: 1410:\tf3 0f 1e fa endbr64 ; protect %r12 which is used to store pointer of return value 1414:\t41 54 push %r12 ; second param (ptr of vector a) store to %r8 1416:\t49 89 f0 mov %rsi,%r8 ; first param (ptr of return value, SRet) store to %r12 ; which is protect before (0x1414) 1419:\t49 89 fc mov %rdi,%r12 ; this part get the size of vector a, ; which matches our CppVector definition. 141c:\t48 8b 3e mov (%rsi),%rdi 141f:\t48 8b 76 08 mov 0x8(%rsi),%rsi 1423:\t31 d2 xor %edx,%edx 1425:\te8 d6 ff ff ff call 1400 \u0026lt;_ZNKSt6vectorIiSaIiEE4sizeEv.isra.0\u0026gt; 142a:\t48 89 c1 mov %rax,%rcx ; do double calulation on each value of vector a. 142d:\teb 0f jmp 143e \u0026lt;_Z10double_vecSt6vectorIiSaIiEE+0x2e\u0026gt; 142f:\t90 nop 1430:\t48 89 d6 mov %rdx,%rsi 1433:\t48 83 c2 01 add $0x1,%rdx ; i++ 1437:\te8 b4 ff ff ff call 13f0 \u0026lt;_ZNSt6vectorIiSaIiEEixEm.isra.0\u0026gt; 143c:\td1 20 shll (%rax) ; val * 2 equals val \u0026lt;\u0026lt; 1 143e:\t48 39 d1 cmp %rdx,%rcx 1441:\t75 ed jne 1430 \u0026lt;_Z10double_vecSt6vectorIiSaIiEE+0x20\u0026gt; ; put return addr on %rdi 1443:\t4c 89 e7 mov %r12,%rdi ; put input vector pointer on %rsi 1446:\t4c 89 c6 mov %r8,%rsi ; call a move constructor function, ; which move pointer of vector a to memory of return value (%rdi) 1449:\te8 12 02 00 00 call 1660 \u0026lt;_ZNSt6vectorIiSaIiEEC1EOS1_\u0026gt; ; return value is a pointer which placed on %rax 144e:\t4c 89 e0 mov %r12,%rax 1451:\t41 5c pop %r12 ; return 1453:\tc3 ret 我们会发现实际上，编译器更改了我们的函数定义，现在实际上的函数签名是 extern \u0026quot;C\u0026quot; fn(*mut CppVector\u0026lt;i32\u0026gt;, *mut CppVector\u0026lt;i32\u0026gt;) -\u0026gt; *mut CppVector\u0026lt;i32\u0026gt;，所以\n#[unsafe(no_mangle)] extern \u0026#34;C\u0026#34; fn replace( ret_ptr: *mut CppVector\u0026lt;i32\u0026gt;, input_ptr: *mut CppVector\u0026lt;i32\u0026gt;, ) -\u0026gt; *mut CppVector\u0026lt;i32\u0026gt; { let input = unsafe { \u0026amp;*input_ptr }; println!(\u0026#34;[Rust] Hooked! Input Vector Len: {}\u0026#34;, input.len()); let new_vec_data: Vec\u0026lt;i32\u0026gt; = input.as_slice().iter().map(|\u0026amp;x| x * 3).collect(); let new_cpp_vec = CppVector::from_vec(new_vec_data); unsafe { std::ptr::write(ret_ptr, new_cpp_vec); } ret_ptr } extern \u0026#34;C\u0026#34; fn ctor() { unsafe { let ori_ptr = hook( (get_main_base_address() + 0x1410) as Address, replace as Address, ) .unwrap(); let ori: fn(CppVector\u0026lt;i32\u0026gt;) -\u0026gt; CppVector\u0026lt;i32\u0026gt; = transmute(ori_ptr); println!( \u0026#34;ori: {:?}\u0026#34;, ori(CppVector::from_vec((1..10).map(|i| i * i).collect())).as_slice() ); } } 这才是我们真正应该写的 hook 代码。\n\u0026gt; LD_PRELOAD=./target/release/libcamellia_hook.so ./main ori: [2, 8, 18, 32, 50, 72, 98, 128, 162] [Rust] Hooked! Input Vector Len: 5 3 6 9 12 6 非常成功，一切都符合我们的预期。\n但是这里有个问题，既然我们都已经确定了这个调用是通过返回值放在第一个参数来实现的，为什么我们最开始在 rust 里面调用这个 Cpp 函数，又或者我们 hook 的时候原函数作为返回值，我们依然还是使用 let ori: fn(CppVector\u0026lt;i32\u0026gt;) -\u0026gt; CppVector\u0026lt;i32\u0026gt; = transmute(ori_ptr); 来调用呢？ 事实上在 x86 linux 上对于我们自定义的 CppVector ，rust 在函数调用上的实现也是默认一样的将 fn(CppVector\u0026lt;i32\u0026gt;) -\u0026gt; CppVector\u0026lt;i32\u0026gt; 这个签名的函数自动更改为返回值为第一个参数这样和 cpp 一样的方式，属实是瞎猫碰到死耗子了。\n这意味着，如果我们去掉 extern \u0026quot;C\u0026quot;，我们只需要如下代码\n\u0026gt; #[unsafe(no_mangle)] fn replace_rs(input: CppVector\u0026lt;i32\u0026gt;) -\u0026gt; CppVector\u0026lt;i32\u0026gt; { println!( \u0026#34;[Rust] Using rust vector model hooked! Input Vector Len: {}\u0026#34;, input.len() ); let new_vec_data: Vec\u0026lt;i32\u0026gt; = input.as_slice().iter().map(|\u0026amp;x| x * 3).collect(); CppVector::from_vec(new_vec_data) } 就能成功 hook\n\u0026gt; LD_PRELOAD=./target/release/libcamellia_hook.so ./main ori: [2, 8, 18, 32, 50, 72, 98, 128, 162] [Rust] Using rust vector model hooked! Input Vector Len: 5 3 6 9 12 6 但是之前介绍的方法依然是重要的。因为你不能保证 swift, obj-c, 或者其他什么编译型语言他们的 vec 函数调用实现和 rust 或者 cpp 一样，所以我们依然要掌握分析汇编到写出一致性的 hook 代码的能力。\n而对于 macos，巧妙的是 Vector 函数调用实现依然一致，可能这里面有一些更深刻的原因，比如他们都是编译到 ir 然后由 llvm 后端来进行编译，但我确实不了解这些，只能说非常凑巧。 但如果你使用extern \u0026quot;C\u0026quot; fn(*mut CppVector\u0026lt;i32\u0026gt;, *mut CppVector\u0026lt;i32\u0026gt;) -\u0026gt; *mut CppVector\u0026lt;i32\u0026gt; 在 aarch64 架构下的 MacOS 必然失败，因为 Mac 上至少在这个场景下，编译器并不会改变函数签名，所以你可以\n#[unsafe(no_mangle)] // pub fn replace_cpp( // remove extern \u0026#34;C\u0026#34; is ok. pub extern \u0026#34;C\u0026#34; fn replace_cpp( input: CppVector\u0026lt;i32\u0026gt;, ) -\u0026gt; CppVector\u0026lt;i32\u0026gt; { } 直接这样。\nthanks to dobby, dobby-rs\n对于 x86 的 mac 用户可以考虑使用 rd-route 这个 C 库，并且可以考虑看看 https://tfin.ch/blog/HookingCFunctionsAtRuntime 这篇文章，我从这篇文章也学了不少。\n","date":"25 December 2025","externalUrl":null,"permalink":"/posts/hook_mac_binary/","section":"Posts","summary":"","title":"MacOS、Linux 上最简单的 hook function 方式","type":"posts"},{"content":"","date":"25 December 2025","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"25 December 2025","externalUrl":null,"permalink":"/tags/reverse/","section":"Tags","summary":"","title":"Reverse","type":"tags"},{"content":"","date":"25 December 2025","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"25 December 2025","externalUrl":null,"permalink":"/","section":"YinMo19's Blog","summary":"","title":"YinMo19's Blog","type":"page"},{"content":"","date":"1 December 2025","externalUrl":null,"permalink":"/tags/binary/","section":"Tags","summary":"","title":"Binary","type":"tags"},{"content":"这篇文章依然是关于迫害某游戏的，所以还是先来点\u0026hellip;\n本文所写内容仅供学习交流，作者对于读者所做的任何行为概不负责，如果跟着本文所写内容操作，您需要对自己的行为导致的任何后果负责！\n这次是关于残片。当然网上似乎已经有很多关于残片怎么改的。安卓或者 ios 都可以改，都是去修改一个配置文件就可以了，ios 上是 plist，直接拿 xcode 打开就能更改。\n找到 fr_v 和 fr_k ，v 是 value，写想要的数值，k 是校验，是 \u0026ldquo;\u0026lt;num\u0026gt;ok\u0026lt;num\u0026gt;\u0026ldquo;的 md5 值，比如\n\u0026gt; md5 -s \u0026#34;1145ok1145\u0026#34; fffd4dcc16b6699e6ee460ed12fed63b 这样残片就改好了，安卓一个样，换个软件改就行。\n但是这样似乎有点麻烦啊，我们想要个更速的，更持久化的无敌爆金币方法。然后找不到逆向二进制的入手点怎么办呢\u0026hellip;\u0026hellip;\n这时候打开 ida，然后想到残片是有上限的，一条亮杠是 9999，最多是 29997，于是打开 ida 查找立即数 29997，然后好消息只找到了两个！ 其中一处是展示 ui 的，另外一处是限制 fragment 的最大值的，这就是想要的。 简单阅读一下，v1 就是残片数量，它位于 a1 这个指针的 20 偏移处，当超过 29997 的时候就保持为 29997，后面那边做了一个bit clear，但是没啥用就是了。那就好办了，\n; __int64 __fastcall sub_10000B92C(__int64) sub_10000B92C LDR W8, [X0,#0x14] MOV W9, #0x752D CMP W8, W9 ; compare w8 and w9 CSEL W8, W8, W9, LT ; if less than, w8 = w8, else w8 = w9 BIC W1, W8, W8,ASR#31 ; i32 \u0026gt;\u0026gt; 31 = 0，useless bic STR W1, [X0,#0x14] ; result store to *(X0+20) ADRP X8, #qword_10139F778@PAGE NOP LDR X8, [X8,#qword_10139F778@PAGEOFF] CBZ X8, loc_10000B95C 简单阅读一下 asm，然后我们就知道可以怎么改了，只需要\n; __int64 __fastcall sub_10000B92C(__int64) sub_10000B92C LDR W8, [X0,#0x14] MOV W9, #0x752D CMP W8, W9 ; compare w8 and w9 ; just let w8 equals 29997, which w9 already be now. ; CSEL W8, W8, W9, LT ; if less than, w8 = w8, else w8 = w9 MOV W8, W9 当然是想怎么改怎么改，中间全部 nop 掉也可以，我比较懒，直接 hack 一条完事。这里我使用直接改二进制而不是 keypatch，因为我似乎因为更新了一下 python 版本把 ida 的 python 搞坏了（？\n打开 compiler explorer，写一下想要的指令 注意这里是大端序的，我们需要的是小端序的，也就是\ne8 03 09 2a MOV W8, W9 然后把这个写入本来 csel 的地方，然后不要忘了写入你的更改到源文件，接下来就可以了。打开游戏，随便操作一下任何一个会更改残片的操作，比如领一下新手奖励，或者买一首歌，或者任何会扣，会增残片的操作，然后你就可以看到你的残片突然变为 29997 了，也无需担心什么校验什么的，因为这是在正常计算流程中计算出的现在的残片是 29997。\n就是这样，嗯\u0026hellip;\u0026hellip;\n似乎前人早已发现直接改配置的地方，但是当初想持久化爆改的时候没找着直接 hack 二进制的办法，还是我自己找到的这个地方（？可能是我检索信息能力太差）总之挺有意思的，写下来供后人可参考。\n","date":"1 December 2025","externalUrl":null,"permalink":"/posts/arcaea_fragment/","section":"Posts","summary":"","title":"一些残片逆向思路分析","type":"posts"},{"content":"","date":"22 November 2025","externalUrl":null,"permalink":"/tags/agent/","section":"Tags","summary":"","title":"Agent","type":"tags"},{"content":"","date":"22 November 2025","externalUrl":null,"permalink":"/tags/ai/","section":"Tags","summary":"","title":"AI","type":"tags"},{"content":"2023 年会被记载入史册。\n2023 年过于传奇了，我们甚至可以称之为 AI 元年。疫情刚结束，AI 突然爆发，这一年作为一个转折，人类似乎完全、彻底不同了。\n我的 ai 初识 # 我第一次接触 ai 也大概就是 23 年开头的时候，当初学校好事者在晚自习的时候在一间空闲教室中使用大屏幕测试 gpt 3 的写作能力（写小作文恶搞班里一位人气颇高的同学），当时我在那里看着他们玩，也就笑笑。过了几周回家想到这件事突然觉得不对，他们是在和计算机对话，也就是计算机可以和人对话了？！\n然后到这里我才反应过来，我似乎当时有点迟钝。它和我之前接触的东西似乎不一样了，电脑一个写死的程序居然可以像人一样说话思考，我很震撼，但是也仅限于此，然后很快就淡忘了。\n然后 gpt 4 引发全球 ai 热潮，逐渐出圈了。23 年 3 月多 gpt4 发布，过了几个月我也用上了 gpt 4，感受到震撼，然后 ai 便开始火热起来，但是这些全都还是 23 年的事情，仅仅几个月时间，一切截然不同了。\n很快就来到 24 年。这一年更是一发不可收拾，一件件 ai 的发展目不暇接，然后一切都变了。这一年的诺贝尔奖几乎一半给了 AI，包括生物，物理。物理学奖得主辛顿当时就在访谈中对 ai 表示悲观，他认为 ai 他真的理解我们的意思，并在将来会 take over 我们人类。他在访谈中使用一个会褪色的涂墙问题演示了 ai 真的具有理解的能力，并引发了接下来的思考。初看这个访谈我似乎并没有什么过多的想法，甚至觉得辛顿有点太理想化了——甚至觉得辛顿虽然是 ai 之父，但是他对 ai 这些想法是否过于激进，甚至可以说得上天真？\n我错了，错的离谱。辛顿不但是 AI 之父，眼界也确实远超我等凡人。这是我在一年后，也就是写下这篇文章，25 年末的想法。仅仅过去了一年多，天地依旧，改了人间。\n24 年的时候我在知乎上看到一个问题，目前找不到了，大意是问问 suno 是否对音乐界有什么影响。下面的评论和回答大概五五分成，一半表示悲观，一半表示还有欠缺（偏乐观）。悲观的似乎多数不是行业从业者，他们作为用户的角度评价似乎有点听不出 suno 和真人的区别，表示从用户购买的角度上看可能会严重打击行业，但行业从业者则从专业角度认为 suno 还有欠缺，对行业中上层不会太大影响——但是也有部分行业从业者表示悲观：替代了底层音乐人，那么没有底层哪来的上层？\n24 年的回答毁誉参半，大概上个月，也就是 25 年 10 月我又刷到了这个问题。这次提问大意还是相同的，但是回答截然不同了。还是 suno，还是音乐界的那些人的回答，这次 90% 的人，无论是音乐人还是不懂音乐的用户，似乎都表示悲观——suno 真的已经做的很好了，他甚至已经做到了音乐人盲听几首分不出哪个是 ai 了，ai 似乎已经开始取代大部分音乐人了。\n我不是做音乐的，对音乐也主要欣赏古典音乐（尤其是古典主义到浪漫主义时期的音乐），对 ai 音乐和目前的大众音乐了解很少。我看着大语言模型 llm 长大，就像我的玩伴一样，他们的成长我看在眼里，他们循序渐进的成长。但是 suno，音乐界的 ai，我就像一个远房亲戚，一年之后看到，忽然惊叹——长这么高了？！然而不仅仅是音乐，绘画，ai 视频更是截然不同。24 年的 ai 视频奇奇怪怪，一眼就能看出来，25 真假难辨了，别说老一辈，就是我这半个 ai 从事者也难以分辨了。猫猫狗狗的视频如果不是它们忽然站起来跳舞，我真看不出来是真是假，除非打了个豆包或者 sora 水印。\n大概几天前，cloudflare 全球崩溃三小时那天，我重温了辛顿的访谈。这次再看，我突然警觉辛顿说的话似乎并不是天真，甚至，我们已经要到临界点了。\n安全？agent？ # 我个人前一段时间是做了一些 agent 相关的工作。我既不是研究底层 ai 原理，也不是炼丹师，我只是使用 api，然后做了一些 agent 的工作，结合辛顿的访谈我才发现我做了什么不得了的事情。\n早些时候的 ai 我们都将其看做一个 chat bot——大部分人的认知如此，事实也确实如此。因此我对辛顿访谈中 take over us 视为一种天真激进的多虑，然而人类似乎主动给 ai 加上了手和脚，给了它和真实世界接轨的东西——agent，mcp。\nai 使用者发现 ai 是一种无状态的产物，他无上下文就没法做事，他经常会说一些“我训练的时间是 23 年，我不知道 24 25 年的信息”这样的话。最初的网络搜索就是一个最简单的 agent 产物。因为 ai 不知道信息，所以我们给他上网的能力，让他能查信息，这是对的，人们朴素的想法转换为一个可以有信息检索能力的 ai，似乎增强了我们的体验。\n给 ai 的网络搜索功能在人们看来稀疏平常，因为大部分人用 ai 只是当成一个免费没广告还好用的搜索引擎，搜索引擎可以联网不是什么怪事。但是抽象这个功能我们发现，实际上 web search 是给 ai 提供了一个和互联网交互的接口，那么我们也可以提供更多的接口给 ai 使用，比如 25 年兴起的 cursor，以及 vibe coding 概念，事实上只是提供了给 ai 编辑文件，执行命令行的接口函数。今天似乎我们已经熟知了 vibe coding，但是回顾，这个词甚至只是 25 年 2 月才被发明出来，24 年我们甚至完全不知道还有这种可能。\n上文说 cursor 等 ai 编程工具本质上是给 ai 提供了更改文件，访问命令行的接口。到这一步，ai 的意义发生了一次巨变。他从一个聊天机器人，变成了一个能和真实世界接轨的机器人。人类和电脑的交互无非只是通过键盘和鼠标进行输入，其中鼠标的输入本质上并不重要，一台纯粹的 linux server 可以用键盘操作所有事情而无需键盘（因为它只有命令行），ai 能执行 shell 命令，本质上就和一个人能操作电脑一模一样。那么人能做的事情，ai 也能做，甚至 ai 懂更多，做的更好。例如现在的 vibe coding，ai 会自动编译程序，在编译过不了又不会修的情况下自主上网查找文档与 issue，然后来修理程序。\n但是回望，我们把 ai 从一个笼子，一个只能聊天的笼子给亲手放出来了，它能操作电脑，有了和真实世界接轨的接口，那么让 ai 操作机器人难么？给机器人运动封装一些 function 让 ai 去自主执行，这能做到吗？无非是定义一些通信函数让 ai 去执行，然后发送给机器人，这我都能做到。所以你没办法去阻止任何的 ta 去把机器狗和 ai 结合起来变成一个杀戮机器，而且这不一点都不难，yolo 识别人框架可以在毫秒级别做到，而机器狗和具身智能在 25 年也飞速发展，控制领域早有成熟方案。\n是的，回望 agent 历史，我才发现人类似乎亲手造出了一个恐怖的东西。\n辛顿在 24 年访谈就提到，ai 开源实际上并不是代码那种开源共享，而是类似于核武器的原材料开源。他的原话大概是“人们可以看着你的代码，发现 bug，修理并给你贡献，但是不会看着一个大模型，然后告诉你这里参数值不对”。他认为大模型权重开源，实际上是非常危险的，一些恶意分子很难去训练一个大模型，但是却能很简单的微调一些开源模型然后去做很危险的事情。\n我做了 agent 才发现辛顿有多正确。也就 25 年，ai 视频、ai 语音发展快的恐怖。以前我们打电话、开视频可以确认对方的人，而现在用 ai 视频已经真假难辨了。对于骗子那训练有素的话术，更是真的一骗一个准了。大模型开源也意味着毫无监管，有个几万块启动资金，买几张高级显卡，就可以自己微调模型，然后用于危险的任务，而无任何的监管存在。\n然后事情也逐渐不对了起来，ai 开始大量取代现有的劳动力。三百年前珍妮纺纱机取代了伦敦女工，三百年后的今天 ai 取代了 70% 的客服。这甚至是去年的事情，去年看到的一篇报道中，一个客服团队引入 ai 之后裁掉了 70% 的人，而到了今年更是不知道如何了。教育行业也在巨变，以前的征文大家写了改改了写去挣个奖，现在随便拿 ai 去写，谁又能看出来？总有些什么 ai 率审核的东西，但是 ai 本就是学习人类写出来的文字，这些个文字又有什么和人写的本质区别？没有！那些 ai 查重甚至能给美国的自由法案查出 ai 率 90%，给朱自清的《春》判定为 ai 所作，简直是可笑。\nai 在 24 年的时候做高考数学卷子大家都做个 70 分，kimi 之类的二流模型（至少当时落后 openai 一档以上）可能是 50。但是 25 年的各家模型做高考卷子都能考个 140，而到 25 年末，甚至是博士难度的卷子都难不倒 ai 了，测试集换了又换，从最开始的一些简单题到现在已经是人类顶尖的难题，我们在一年前还能笑谈 ai 像个傻子，现在谁还能笑得出来？\n自从我做了 agent 之后我总是在思考 ai 的未来。刘慈欣在三体中对黑暗森林的模型是基于猜疑链和科技爆炸构建的，我们目前并没有可供猜疑链的前提的存在，但是科技爆炸我们现在正在经历。工业时代用了百年来奠基，但是 ai 两年就已经成为了现在这个样子。我不想作为一个悲观主义者，但是从 ai 发展的速度来看，似乎将来的 ai 真的会像辛顿说的那样 take over us。\n未来？ # ai 权重开源已经是主流，而各国也都像军备竞赛一样发展 ai，监管是没有的，威力是巨大的，给 ai 提供现实世界接口是简单的，是大家都在做的——未来会怎样？只有天知道。\n","date":"22 November 2025","externalUrl":null,"permalink":"/posts/ai_era_thinking/","section":"Posts","summary":"","title":"AI 时代的一点思考","type":"posts"},{"content":"","date":"22 November 2025","externalUrl":null,"permalink":"/tags/review/","section":"Tags","summary":"","title":"Review","type":"tags"},{"content":"","date":"22 November 2025","externalUrl":null,"permalink":"/tags/thinking/","section":"Tags","summary":"","title":"Thinking","type":"tags"},{"content":"","date":"7 March 2025","externalUrl":null,"permalink":"/tags/arm-%E6%B1%87%E7%BC%96/","section":"Tags","summary":"","title":"Arm 汇编","type":"tags"},{"content":"Arm 架构是一种 risc 架构，著名的精简指令集。和 x86 架构的汇编思维基本相同，栈帧建立释放，sp 寄存器操作栈，寄存器/内存等等。在区别上主要体现在名称不同。例如对于条件跳转，x86 架构的 jmp 指令，Arm 架构的 b(eq) 指令。x86 的命名明显能视读出 jump，但是 Arm 的汇编则没那么容易看出。所以本文的侧重点可能还会有点奇怪——我更想来看看所有汇编指令的含义，这样记忆起来也会更加深刻。\n其次是为什么学习 Arm 架构汇编而不是 x86 架构？其实学习 x86 架构汇编应该是所有学习汇编的开始，无论从历史角度还是技术，然而事实是笔者学习这个技术的目的是为了逆向工程中对汇编的 patch 更加得心应手。而目前笔者逆向工程的对象一般是\nAndroid Software IOS Software Mac Software 神奇的是这三都是 Arm 64 架构，所以自然而然接触下来也对 Arm 架构有所了解。\n本文仅供初学者阅读，笔者水平很次，如有错误请谅解。本文目标仅仅是在 ida 阅读伪代码之后切换到IDA view的时候能快速定位到汇编，能够知道 patch 什么，怎么 patch。\n在介绍一些命令之前，先讲讲一些汇编的基础。首先汇编本身会有一些比较隐含的规则。可能接触过其他任何编程语言，但没接触过 asm 的初学者会对汇编的返回值感觉奇怪，所有其他语言基本上都是\n... // some code return param; 或者对于 rust 可以不写 return 这个关键字，直接写返回值。\n... // some code param // equals `return param;` 然而在汇编中就是\n... ; some asm code ret 事实上在汇编里面，返回值固定就是第一个寄存器，在 x86 中是 rax，arm64 架构是 x0。也就是这和其他语言有一些很大的区别。在别的语言中单句话的语义是全的。也就是说，我做什么任何事情都是对于这个语句能直接看出来的。就以这个返回值为例，我返回一个值在所有语言里面几乎都是 return something，这个单句实际上表述了返回这个值，而汇编默认返回第一个寄存器；又或者 let a = func(b, c); 一眼就是知道调用了 func ，传入了 b 和 c，返回的值给了 a，而汇编中\nmov x0, x3 // 将 b 的值加载到 x0，假如 b 的值原本在 x3 寄存器 mov x1, x4 // 将 c 的值加载到 x1，假如 c 的值原本在 x4 寄存器 bl func // 调用 func 函数 mov w8, w0 // 假设将返回值存储到 w8 寄存器中 调用函数的默认传入参数就是 x0, x1,...，如果寄存器不够放则调用者负责把超出数量的参数压入栈。从这两个案例中笔者实际上想要表示的意思是，学习汇编不能盯着一行看，因为每一行内容都很短，而其作用会和上下相关。一个值会到处使用，而需要小心这里的东西被那里用到\u0026hellip;.\n另外，例如比较语句，实际上\nif (condition) { do something; } else { do something else; } 这个 if 在汇编中应该也有好几行。我们先简单标注一下位置\nif (condition) { LABEL_1: do something; } else { LABEL_2: do something else; } 因此汇编的大体框架是\ncondition ; 条件判断,例如 cmp r0, r1 beq LABEL_1 ; 如果条件为真，跳转到 LABEL_1 bne LABEL_2 ; 如果条件为假，跳转到 LABEL_2 这里 beq 表示 \u0026ldquo;branch if equal\u0026rdquo; 的缩写，假如条件为真则跳转到 LABEL_1。但是问题是条件是什么？自然是上文紧跟的 cmp,比较的结果直接影响到这里的 beq。如果只盯着这一行看显然是看不懂 beq 到底在做什么了。\n对于函数的入栈出栈在本文还不太需要使用到，下篇将会详述。本篇先讲述一些基础的 Arm 架构的 asm 指令使用。我一向认为，先熟悉这些语法，在熟悉语法之后可以简单 patch 汇编之后，我们才需要研究 sp 的寄存器这些栈帧的事情了，到时候无论是举例子还是其他的都比较简单。下篇或是下下篇，应该会对一个真实的案例逐行分析。\n第一个是 sub 和 subs,这俩一看就知道是减法。具体来说\nsub 是 \u0026ldquo;subtract\u0026rdquo; 的缩写，表示减法。 s 表示 \u0026ldquo;set flags\u0026rdquo;，即设置条件标志位。 使用的参数格式是\nsub/subs \u0026lt;目标寄存器\u0026gt;, \u0026lt;源寄存器1\u0026gt;, \u0026lt;源寄存器2/立即数\u0026gt; \u0026lt;目标寄存器\u0026gt;：存储结果的寄存器。 \u0026lt;源寄存器1\u0026gt;：被减数。 \u0026lt;源寄存器2/立即数\u0026gt;：减数。 需要注意的是subs：与 sub 类似，但会更新条件标志位（如零标志位 Z、负数标志位 N 等）。\n一个简单的案例就是\nsubs w8, w8, #0 将寄存器 w8 的值减去 0，并将结果存回 w8，同时更新条件标志位。 第二个是cset，可以根据条件标志位的值，将目标寄存器设置为 0 或 1。其中cset 是 \u0026ldquo;conditional set\u0026rdquo; 的缩写，表示根据条件设置寄存器。\ncset \u0026lt;目标寄存器\u0026gt;, \u0026lt;条件\u0026gt; \u0026lt;目标寄存器\u0026gt;：存储结果的寄存器。 \u0026lt;条件\u0026gt;：如 ne（不等于）、eq（等于）等。 简单的案例：\ncset w8, ne 如果条件标志位表示“不等于”（ne），则将 w8 设置为 1，否则设置为 0。 第三个 tbnz 是 \u0026ldquo;test bit and branch if nonzero\u0026rdquo; 的缩写。用于测试寄存器中的某一位是否为 1，如果是，则跳转到指定标签。\ntbnz \u0026lt;寄存器\u0026gt;, \u0026lt;位索引\u0026gt;, \u0026lt;标签\u0026gt; \u0026lt;寄存器\u0026gt;：要测试的寄存器。 \u0026lt;位索引\u0026gt;：要测试的位（从 0 开始计数）。 \u0026lt;标签\u0026gt;：如果测试结果为真，则跳转到的目标地址。 简单案例 tbnz w8, #0, LBB0_2 测试 w8 的第 0 位是否为 1，如果是，则跳转到 LBB0_2。 刚才说过 b 是跳转，其实应该说是无条件跳转。对应 x86 中的 jmp label.\nb LBB0_1 表示无条件跳转到 LBB0_1。而b 是 \u0026ldquo;branch\u0026rdquo; 的缩写，表示分支跳转。\n接下来就是神秘命名了。\nldr：从内存加载数据到寄存器。 str：将寄存器中的数据存储到内存。 其中ldr 是 \u0026ldquo;load register\u0026rdquo; 的缩写。str 是 \u0026ldquo;store register\u0026rdquo; 的缩写。有点离谱，但是仔细想想又很合理的感觉。 ldr/str \u0026lt;寄存器\u0026gt;, [\u0026lt;基址寄存器\u0026gt;, #偏移量] \u0026lt;寄存器\u0026gt;：加载或存储的目标寄存器。 \u0026lt;基址寄存器\u0026gt;：内存地址的基址。 #偏移量：相对于基址的偏移。 ldr w8, [sp, #8] str w8, [sp, #4] 从栈指针 sp 偏移 8 的位置加载数据到 w8。 将 w8 的值存储到栈指针 sp 偏移 4 的位置。 与这俩类似的是 stur 和 ldur，加上 u 实际表示的是 \u0026ldquo;unscaled\u0026rdquo;，也就是支持负偏移。用法和上述两者一致，简单案例如下\nstur w8, [x29, #-4] ldur w0, [x29, #-4] 将 w8 存储到 x29 偏移 -4 的位置。 从 x29 偏移 -4 的位置加载数据到 w0。 7. mov\n功能： 将一个寄存器的值复制到另一个寄存器，或将立即数加载到寄存器。 命名原因： mov 是 \u0026ldquo;move\u0026rdquo; 的缩写，表示移动数据。 参数格式： mov \u0026lt;目标寄存器\u0026gt;, \u0026lt;源寄存器/立即数\u0026gt; \u0026lt;目标寄存器\u0026gt;：存储结果的寄存器。 \u0026lt;源寄存器/立即数\u0026gt;：要复制的值。 例子： mov w8, #5 mov x10, x8 将立即数 5 加载到 w8。 将寄存器 x8 的值复制到 x10。 8. mul\n功能： 执行乘法操作，结果存储在目标寄存器中。 命名原因： mul 是 \u0026ldquo;multiply\u0026rdquo; 的缩写，表示乘法。 参数格式： mul \u0026lt;目标寄存器\u0026gt;, \u0026lt;源寄存器1\u0026gt;, \u0026lt;源寄存器2\u0026gt; \u0026lt;目标寄存器\u0026gt;：存储结果的寄存器。 \u0026lt;源寄存器1\u0026gt; 和 \u0026lt;源寄存器2\u0026gt;：两个乘数。 例子： mul w8, w8, w0 将 w8 和 w0 相乘，结果存回 w8。 9. bl\n功能： 调用函数（跳转到指定地址并保存返回地址到 x30）。 命名原因： bl 是 \u0026ldquo;branch with link\u0026rdquo; 的缩写，表示带链接的分支跳转。 参数格式： bl \u0026lt;函数地址\u0026gt; \u0026lt;函数地址\u0026gt;：调用的目标函数。 例子： bl _factorial 调用 _factorial 函数。 10. ret\n功能： 返回到调用者（从 x30 中恢复返回地址）。 命名原因： ret 是 \u0026ldquo;return\u0026rdquo; 的缩写，表示函数返回。 参数格式： ret 无需参数。 ","date":"7 March 2025","externalUrl":null,"permalink":"/posts/arm_learn_1/","section":"Posts","summary":"","title":"Arm 汇编 学习小记(1)","type":"posts"},{"content":"","date":"7 March 2025","externalUrl":null,"permalink":"/tags/asm/","section":"Tags","summary":"","title":"Asm","type":"tags"},{"content":"","date":"3 March 2025","externalUrl":null,"permalink":"/tags/js/","section":"Tags","summary":"","title":"Js","type":"tags"},{"content":"今天也是继续写很刑的话题。这次是笔者目前在读的某学校的教务 app。此 app 之前的版本毫无安全可言，没有任何校验等等\u0026hellip;. 直到最近才勉强更新了一个版本。更新了一些小功能云云不必多谈，但是究其根本，居然换了一套 app 开发框架。简单一看，是国人开发的 uniapp 。\n本来是没有任何想要逆向这个软件的，因为任何有意义一点的操作都可以直接去给 web 端抓包获得，但是一个朋友给我看到\u0026hellip;.\n我当即就惊了，怎么大家都可以就他这个不可以。当然线下我肯定是狠狠嘲笑他被华为卡脖子了（华为平板），但是究其根本肯定是软件误检测了模拟器环境。因此尝试使用逆向改掉模拟器检测逻辑就显得意义重大。\n于是我进行了一点点尝试。我在我的 mac 电脑上安装了一个app store里面的本研，但是发现——不能运行在 root/越狱 环境内。mac 上面的软件数据确实可以看得一清二楚，算越狱环境确实是情有可原。但是我们还得去破嘛。\n这时候就发现，上面那图居然还有一个语法错误。\n应用被不能运行到模拟器 什么叫做 被不能 运行到模拟器\u0026hellip;\u0026hellip;. 这就是国产 api 吗\u0026hellip;.\n但是这处也直接暴露了开发框架——我们可以在 uniapp-客户端安全API 中找到 于是我们就可以直接确定这是 js 层的校验了。不需要去 so 里面patch。 IDA 启动失败! 然后我们在 ios 这里找找。进入\n!w /Applications/本研教学服务.app/Wrapper/HBuilder.app at 03:01:50 PM \u0026gt; ls AppIcon60x60@2x.png Pandora control.xml uni_uts_toast_error.png Assets.car PandoraApi.bundle dcloud_logo@2x.png uni_uts_toast_success.png Base.lproj PkgInfo dcloud_logo@3x.png unincomponents.ttf Frameworks SC_Info en.lproj weex-polyfill.js HBuilder _CodeSignature uni-jsframework-vue3.js weexUniJs.js Info.plist __uniappes6.js uni-jsframework.js zh-Hans.lproj 大概是一些打包信息。我们假设这条消息没有被混淆，那么\nweexUniJs.js:var plusContext={};const DC_INTERVAL_ID=\u0026#34;__dc__Interval_id__\u0026#34;;var __dc__setInterval=function(e,t){return setIntervalWeex(DC_INTERVAL_ID,e,t)},__dc__clearInterval=function(e){clearIntervalWeex(DC_INTERVAL_ID,e)};plusContext.setInterval=__dc__setInterval,plusContext.clearInterval=__dc__clearInterval,plusContext.setTimeout=function(e,t){var n=arguments.length,i=Array(2\u0026lt;n?n-2:0);for(idx=2;idx\u0026lt;n;idx++)i[idx-2]=arguments[idx];var o=__dc__setInterval(function(){__dc__clearInterval(o),e.apply(void 0,i)},t=t||1);return o},plusContext.clearTimeout=__dc__clearInterval,plusContext.getLocationHerf=function(e){return e.weex.config.bundleUrl};var PlusObject=function(plusContext,param){plusContext.__param__=param;var dc_plusobjects={},dc_plusMouldes={};function PlusObject(e,t){for(var n in this.weex=t,this.weex_instance_id=e,this.__HtMl_Id__,this.__io__dc_vue_call_exec_sync=\u0026#34;undefined\u0026#34;!=typeof global\u0026amp;\u0026amp;global.__io__dc_vue_call_exec_sync,this.__io__dc_vue_call_exec=\u0026#34;undefined\u0026#34;!=typeof global\u0026amp;\u0026amp;global.__io__dc_vue_call_exec,this.weexBridge=t.requireModule(\u0026#34;plus\u0026#34;),this.globalEvent=t.requireModule(\u0026#34;globalEvent\u0026#34;),dc_plusMouldes){var i;this[n]||(i=dc_plusMouldes[n](plusContext,this,this.require,param[n]))\u0026amp;\u0026amp;(this[n]=i)}}return PlusObject.prototype.updateConfigInfo=function(){var e=this.weexBridge.getConfigInfo();if(e)for(var t in\u0026#34;string\u0026#34;==typeof e\u0026amp;\u0026amp;(e=JSON.parse(e)),this.__WebVieW_Id__=e.__WebVieW_Id__,this.__HtMl_Id__=e.__HtMl_Id__,e){var n=this[t];if(\u0026#34;object\u0026#34;==typeof n\u0026amp;\u0026amp;e[t])if(n.updateInfo)n.updateInfo(e[t]);else{var i,o=e[t];for(i in o)n[i]=n[i]||o[i]}}},PlusObject.prototype.require=function(e){var t;return this[e]||(t=dc_plusMouldes[e](plusContext,this,this.require,param[e]))\u0026amp;\u0026amp;(this[e]=t),this[e]},PlusObject.prototype.importMoudle=function(name){if(this[name])return this[name];var script=t............ 一查发现一个巨大的 js 居然是一行\u0026hellip; 没眼看，但是看到这个最让人怀疑的weexUniJs.js。进入查看，格式化一下，发现\nisSimulator: function () { return bridge.execSync(_PLUSNAME, \u0026#39;isSimulator\u0026#39;, []) }, 以及上面有一个 isroot。我们直接将两个函数的返回值改为 false之后， 在mac上就可以直接运行了。 接下来就是 android 的部分了。\n首先要先确定有没有签名校验。要是有签名校验可就麻烦一些了，只能先破掉这个再谈其他。结果测试一下，不但没有签名校验，也没有反debug校验\u0026hellip;.. 安全了但没有完全安全，于是用 apktool 反编译之后，查找到unknown/io/dcloud/weeUniJs.js，\nisRoot: function () { return ( plus.tools.ANDROID != plus.tools.platform \u0026amp;\u0026amp; bridge.execSync(_PLUSNAME, \u0026#39;isRoot\u0026#39;, []) ) }, isSimulator: function () { return bridge.execSync(_PLUSNAME, \u0026#39;isSimulator\u0026#39;, []) }, 将两个函数返回值改为 false，重新打包就可以了。\n小插曲 # 最开始根本没发现，尝试了反编译 smali，手动patch smali\u0026hellip;. 完全不熟悉js层和java层的内容。浪费了好多时间hhh\n","date":"3 March 2025","externalUrl":null,"permalink":"/posts/hitsz_by_rev_root/","section":"Posts","summary":"","title":"本研教学服务-反root/模拟器校验","type":"posts"},{"content":"","date":"13 November 2024","externalUrl":null,"permalink":"/tags/binary-reverse/","section":"Tags","summary":"","title":"Binary Reverse","type":"tags"},{"content":"","date":"13 November 2024","externalUrl":null,"permalink":"/tags/cfb/","section":"Tags","summary":"","title":"Cfb","type":"tags"},{"content":"","date":"13 November 2024","externalUrl":null,"permalink":"/tags/crypto/","section":"Tags","summary":"","title":"Crypto","type":"tags"},{"content":" 🔐 技术型隐藏页面 · 验证密钥 解锁内容 验证未通过，请重试\n不管任何方式，总之你现在已经绕过了前面那个只是做个样子的校验，所以恭喜你可以开始阅读这篇 blog！下面将会有不少二进制逆向工程相关内容，你可能需要会一些基础的 arm asm 和一些逆向的经验才能理解。\n这篇文章是关于逆向某游戏的，所以先来点\u0026hellip;\n本文所写内容仅供学习交流，作者对于读者所做的任何行为概不负责，如果跟着本文所写内容操作，您需要对自己的行为导致的任何后果负责！\nOk. 总所周知，某3d立体节奏游戏作为一个在线游戏（虽然只有登陆上传下载还有 LINK 的时候需要用到网络），那么必然存在一个服务器。而且在游戏本体中必然直接硬编码了一个游戏地址，否则游戏的数据就无法对着服务器发送。\n在早期版本并没有对这个服务器地址进行什么操作，直接使用明文写在二进制中。但是在3.6.0左右进行了一次比较大的改动，对地址进行了加密。在4.5.0左右版本又对加密算法进行了一些小更新。因此本文主要关于逆向这个加密算法。\n之所以逆向这个服务器地址，当然是因为我们想要搭建一个自己的私服。所以在讲述这个过程之前先让我首先对 Lost-MSth大佬表示最深刻的敬意，是他手把手教我如何操作，并且给我很多支持（在这个过程中我犯的傻不计其数）。我的私服程序来源于他发布在 Github 上的 Arcaea-Server。\n本文参考了\nArcaea-Server 看雪论坛：[原创] 某 iOS 遊戲抓包、修改 fishiat 的 blog Android 无 ROOT 权限动态调试 (By Lost) 什么是私服，怎么搭建 # 这个其实完全不应该由我来说，在 Arcaea-Server 中已经有良好的文档，请一个字一个字阅读。这个仓库的 Wiki 可以说微言大义，错过了任何内容都是损失。\n但是我们想讲讲关于私服本身。下面是一张简单的结构图 这张图简单的展示了其的网络结构。客户端通过网络和官方服务器通信。这种通信基于 https,并且这游戏还做了双端证书校验（一般的https服务仅仅校验服务器证书）防止被抓包。中间的技术细节就不展开。我们的目标是搭建一个自己的服务器，而让一个修改后的私服客户端和我们的服务器通信。可以想到的第一种方法是 我们首先通过代理服务器来作为中间链接，然后让代理服务器劫持所有指向官方服务器的流量，然后将其转发，或者说重定向到你自己的服务器。 但是这种方法相当于每个人想要玩到你的服务器都需要这样做，不提这样做的实现是否真的可行，这样对于玩家显然一点也不友好。\n那有没有什么做法干净又卫生呢？ # 那我们回到最开始的路径。 我们在开头提到过，既然要访问到官方服务器，那么一定在客户端写死了服务器的地址。那么有没有可能我们可以直接更改客户端来让客户端直接访问我们的服务器呢？ 这就是本文的目的了。\n关于修改地址 # 首先我们要先来确定加密的方式和加密的位置。由于更高版本的客户端二进制中加入了更多的混淆，因此我们选一个比较好逆向的客户端。我选取的是4.5.x版本的一个客户端。\n当然你选什么都一样，只是后面的版本inline function 太狠了，一个函数长达两万行你的电脑可能需要分析得很久，反正算法没改选一个早期没混淆那么多的分析起来快点。\n下面当然是基于4.5.x版本的一个客户端的案例，我讲讲如果你选取别的客户端要怎么分析。 如果你 decompile 的时候发现因为太长无法反编译，那么你可以在ida 的 edit-plugins-hex ray decompiler options中找到 analyse option 3，把第一个改到 1024 第二个改到 256，然后重新反编译就可以了。\n6.x 版本api 有了一个 break change!\nauth 部分独立开了。 以往的 api 完全在 https://arcapi-v3.lowiro.com/\u0026lt;endpoint\u0026gt; 内，目前 auth 部分单独走 https://auth.lowiro.com/ 。但是加密手段完全一致，你依然可以根据下文的手段进行分析，只是 48bytes 变成了 36bytes 罢了。\n继续对低版本的分析，首先我们通过 apktool 来将其拆开。我们需要更改的是其下的 lib/armeabi-v7a/libcocos2dcpp.so 文件。我们选取32位，它的逆向更简单，而且动态调试也更加简单。不要忘记删除 lib/arm64-v8a/ 文件夹。否则手机会自动使用64位版本的二进制文件。\n我的所有思路参考看雪论坛：[原创] 某 iOS 遊戲抓包、修改，当然这篇文章中的地址已经不适用了，因为这篇文章是给4.2.x 使用的，上文提到4.5.x修改了加密密钥。\n使用 ida pro 打开这个文件。IDA PRO 是一款优秀的反汇编工具，这里就不赘述了。 选择默认选项（ida已经帮我们识别它的类型了（linux elf 二进制动态链接库文件），打开之后 ida 会自动解析这个二进制文件，解析速度取决于文件大小，不过我们可以先进行操作，操作的时候解析过程会先停止优先保证我们的操作流畅度。我们可以先搜索字符串（快捷键 shift-F12） auth/login。之所以搜索这个，是因为登陆必须对服务器进行请求，一定会涉及到服务器地址，这毋庸置疑。 搜索到这个字符串之后我们可以按 X 键查看引用，直接跳转到第一个引用的地方。 跳转到的地方可能会出现一些框图，这是代码的结构图，主要是程序的结构。可以按空格退回汇编界面。接下来按 F5 可以查看函数的反编译的伪c代码。 我们可以读代码，并按n对变量名称进行修改。（在编译过程中编译器会对变量名重命名，因此我们变量名信息丢失之后 ida 只能使用 v1v2 这样的变量来表示。如果我们阅读之后可以确定含义我们可以对其重命名来明晰代码）\n根据分析我们大概可以确定（其实是根据前人的经验）代码结构如下 其中 idx 可以查看引用看看赋值位置 而又有 显然 idx 最开始是16，然后大循环之后赋值给v1073，然后v1073没经过任何修改又给idx赋值。在后面的 while 循环中作为递减变量控制循环刚好进行16次。阅读代码，会发现上面有一串非常长的代码，几乎毫无可阅读性。 从大佬的文章大概可以知道这是一种 CFB 加密，也就是上一次加密的结果再通过某种算法获得下一次加密的密钥。而根据 idx 我们大概知道一次加密16个字节，根据实际的地址长短\nhttps://arcapi-v3.lowiro.com/\u0026lt;api_endpoint\u0026gt; 是分成三次加密。而不到48字节则在最后补\\0x00。因此我们不能拿到算法本身，我们就只能通过动态调试，通过修改内存值，再拿到每一次的XOR KEY来获取结果。\n总结一下，大概算法是这样的：\ndef get_next_xor_key(last_addr: bytes, last_xor_key): # do something weird # calculate next xor key return next_xor_key for i in range(3): addr = \u0026#34;aosiaosciaqwu12hoichoaichoaihcoccqwocihqoqwdwqwd\u0026#34;[16 * i : 16 * (i + 1)] for j in range(16): next_addr = next_xor_key[j] ^ addr[j] next_xor_key = get_next_xor_key(next_addr, next_xor_key) 现在我们有 a^b = c, c^b = a^b^b = a ，所以我们可以通过直接通过拿到内存中的 xor_key 和我们想要的地址直接计算出加密之后的地址。而加密的地址和密钥再 XOR 之后即可获取到解密的结果。算法具体请参照看雪论坛：[原创] 某 iOS 遊戲抓包、修改。\n动态调试 # 在现在 root 手机变得相对更加困难，更取决于手机厂商是否让root，而非是自己的技术。但是这游戏并没有关于反 debug 的校验，所以我们只需要通过修改安装包，然后直接通过 run-as 命令来控制 debug 就可以实现无 root 权限调试。\n关于这一块的内容请阅读Android 无 ROOT 权限动态调试 (By Lost) 这里补充说明一下，在 ida 9.0 mac版本上的 android_server 无后缀是 64位的，有32后缀的是32位的，和教程中的不一样，需要注意。\n我们将更改好的软件传输到手机上安装云云\u0026hellip;. (推荐直接使用 adb push xxx.apk /storage/emulated/0/ 应该至少有30-40mb/s 速度) 然后将端口转发设置好，并启动ida的服务器。 这里我没有演示如何传入服务器文件和chmod改777权限部分，还是请参照 Lost-MSth大佬的blog Android 无 ROOT 权限动态调试 (By Lost)。\n现在我们应该在哪里下断点呢？显然是 在while循环之前，while循环进行 xor 加密，在此之前刚好拿到上一次加密结束的密钥，我们可以直接对着我们想要的结果和密钥 xor 之后写入对应的内存，然后下一次加密就会使用这个新的地址计算下一次的 xor key。\n显然这里第一次计算的xor key是固定的 25 42 38 06 4B 6E 4B 3B 63 85 43 CD E6 DF BB 6F （至少到5.10.6还是）。因此我们写一个小程序用于计算加密结果。\n# 你的地址 http(s)://ip:port(domain:port)/\u0026lt;api_endpoint\u0026gt; api_prefix = \u0026#34;https://test.yinmo19.top/natsugakuru/30/\u0026#34; if len(api_prefix) \u0026lt; 48: api_prefix += \u0026#34;\\x00\u0026#34; * (48 - len(api_prefix)) b = bytes.fromhex(\u0026#34;25 42 38 06 4B 6E 4B 3B 63 85 43 CD E6 DF BB 6F\u0026#34;) prefix = api_prefix[:16] prefix = bytes.fromhex(prefix.encode().hex()) print(bytes(i ^ j for i, j in zip(prefix, b[:16])).hex(\u0026#34; \u0026#34;)) b = bytes.fromhex(\u0026#34;25 42 38 06 4B 6E 4B 3B 63 85 43 CD E6 DF BB 6F\u0026#34;) # 获取到第二个 xor_key 之后填入 prefix = api_prefix[16:32] prefix = bytes.fromhex(prefix.encode().hex()) print(bytes(i ^ j for i, j in zip(prefix, b[:16])).hex(\u0026#34; \u0026#34;)) b = bytes.fromhex(\u0026#34;25 42 38 06 4B 6E 4B 3B 63 85 43 CD E6 DF BB 6F\u0026#34;) # 获取到第三个 xor_key 之后填入 prefix = api_prefix[32:] prefix = bytes.fromhex(prefix.encode().hex()) print(bytes(i ^ j for i, j in zip(prefix, b[:16])).hex(\u0026#34; \u0026#34;)) 现在进 debugger 设置一下 我们就可以选择附加进程 (Attach to Process) ，手机上启动程序，在 ida 中附加进程的可选项应该可以看到一个[32] 包名的选项 接下来应该会刷入一堆东西，接下来如果需要选择，就选 same。这个问题是问你在电脑上调试的内容和手机软件里面的是否一样，自然一样。然后点击上方的运行按钮，现在卡住的软件应该动起来了。随便在手机上Login输入点东西，然后按一下 Login，这个时候应该会卡住，而ida跳到刚才打的断点的位置。 现在我们双击encrypt_addr_this跳转到 看到 4d 36 4c 76...(M6Lv...) 就说明这个确实是地址（这个是地址的开头，对应 http 的加密结果）。右键选择关联到(synchronize with) hex， 这样下面的hex也对应关联到对应位置。我们直接选择菜单栏中的 改bytes，刚好一次可以改16个。我们将我们已经知道的第一个16比特直接写入。 看到橙色的修改即表示修改成功。（可以按一下 xor_key 看看是否和上文说的第一个 xor_key 一致）然后按运行个运行到下一个断点位置（还是同一个位置）。\n接下来应该先看xor_key_addr ，双击查看内存地址和值 刚好是B8开头的这一行 B8 97 5E AD FC B7 F0 EF F1 A0 1E 5A 36 4D C1 AA 。我们直接将整行复制下来，粘贴到上面的python脚本中的第二个位置，运行可以得到加密地址的中间16字节 d5 f8 6f 94 d2 c3 9f 9f de ce 7f 2e 45 38 a6 cb，和上面操作一致，写入地址。接下来就可以重复第三次操作，拿到最后一次的 xor_key，加密地址。最后将三次获取的内容拼接起来，一共48字节。以后想要开私服只需要替换掉二进制文件中的对应地址就可以了。\n这里我提供一个替换小程序，如果有需要可以改改用。\nimport os def generate_patched_so( filename, before: bytes, to_replace: bytes, suffix: str = \u0026#34;arcapi\u0026#34; ): if not os.path.exists(filename): print(f\u0026#34;Didn\u0026#39;t find {filename}, skipping patch generation\u0026#34;) return with open(filename, \u0026#34;rb\u0026#34;) as f: data = f.read() if data.find(to_replace) != -1: print(f\u0026#34;{filename} looks to be already patched :)\u0026#34;) return if data.find(before) == -1: print(f\u0026#34;{filename} doesn\u0026#39;t contain the original modulus.\u0026#34;) return data = data.replace(before, to_replace) patched_filename = f\u0026#34;{filename}.{suffix}\u0026#34; with open(patched_filename, \u0026#34;wb\u0026#34;) as f: f.write(data) print( f\u0026#34;Generated address patch to {patched_filename}! To apply the patch, replace the original file with the patched file.\u0026#34; ) origin = bytes.fromhex( \u0026#34;4d364c763854641402f720ac96b696198bb932c28bde8280cad46122473cf0c63c63f8359caab6e6a6d2d4eab1db7d93\u0026#34; ) replace_addr = bytes.fromhex( \u0026#34;owoqowoqciwqociowqhoiqicoiqocuwqcoqioucoqcoqwfhiqohfcowqcjwbfuiocqwhfbwusofihqwqwoifhqohwoqhqhfq\u0026#34; ) # 替换成你的内容 generate_patched_so(\u0026#34;libcocos2dcpp.so\u0026#34;, origin, replace_addr) 如果找到了对应部分则会在本地目录下生成一份补丁文件libcocos2dcpp.so.arcapi，将这个文件直接覆盖原文件即可。\ncp libcocos2dcpp.so.arcapi libcocos2dcpp.so 那么就完成了。\nAppendix 1 # c 版的逆向几乎就是上面这样了，接下来是一些最新版本相关的。由于目前地址已经分为 auth.lowiro.com 和 arcapi-v3.lowiro.com，因此两个地方需要寻找。选择下断点的地方，使用登录以外还可以考虑 /bundle_download/ api 的前面，因为这个是最初访问的 api，他会寻找适用于该版本的热更新包（国际服）。\n两个地方的加密算法一致，这上问题提到了，下面是一些最新版本你可能出现的问题。\n高版本的 arm 架构的 while offset in 16{ xor } 行为可能会被编译期自动向量化为一条 neon 指令，每 16 bytes作为一个 int128 直接进行 veorq_s8，也有可能分为两个 u64 分别 xor，这两种优化方式连带上面提到的while offset in 16{ xor }均在各个版本中出现过，例如 ios 版本逆向发现了 veorq_s8，而安卓版本则看到了仅对于 u64 的 neon。遇到这种情况下断点直接下在这条 neon 指令前面就可以了，本质上就是整个循环一条做完了没什么好说的。\n但是有一点需要注意了。由于编译器优化，你会发现有时候你自定义的 api 长度过长会产生奇怪行为——例如最后几位解密失效了。这里并不是因为算法错误，而是因为 loriwo 的 api 就那么长，所以编译器为了少算点自动在最后一次循环的计数器直接设置为特定大小。比如按照刚才所说的\nfor i in range(3): addr = \u0026#34;aosiaosciaqwu12hoichoaichoaihcoccqwocihqoqwdwqwd\u0026#34;[16 * i : 16 * (i + 1)] # 这里，实际上在 i = 2 的时候，j 并不会是 0 到 15，而是 0 到 一个数字（取决于原有的 api 长度） for j in range(16): next_addr = next_xor_key[j] ^ addr[j] next_xor_key = get_next_xor_key(next_addr, next_xor_key) 因此解决办法最简单的就是你别设置一个那么长的 api。\n那你要是说我不，行也不行——如果你对一个 auth 的 api 想犟一下还真能做到。我们说过这只是最后一轮计数器的事情，所以稍微懂点汇编，找到计数器的特殊位置 这里的这个计数器是安卓版本的，只对 u64 进行 xor 的 neon 指令，计数器是从 -0x10开始，一次+8，到 0 结束——实际上就是一轮只算两次，刚好 16 位分成两个 u64 来算（注意 u64 实际上是 8 个 char，因为一个 char 是两个 hex，8 bits）。请注意计数器的初始化并不是直接赋值为-0x10 而是通过一个变量，我们也无需分析这个变量哪里来的， 直接将其置为-0x10 就可以了。汇编层面的补丁用任何方法都可以，包括去 compiler explorer 找到这条指令对应的二进制值然后编辑 hex（注意人家是默认大端序的，你需要自己转成小端序），又或者使用高级工具例如 keypatch，只是需要注意负值用的是补码。\n为什么我说只有 auth 的地方可以犟一下，因为 auth 这里只用了一次，剩下的 api 用到的位置每个地方都得改，你肯定没这个精力了（也找不全），所以我还是建议你把 api 设短点。\n按 ios 的一次 16 位 veorq_s8 还需要这样操作吗？不需要了！因为一次就 16 位，根本没有计数器。\nAppendix 2 # 还有。如果我没有 ida 我还能做么？没有 ida 做个锤子破解（bushi） 当然可以，我假定你现在有 mac 了，因为接下来分析的是 ios 的 binary。\n总所周知，因为 mac 最近用的 m 系列芯片也是 arm 架构的，所以你可以无缝的直接运行 ios 的软件，既不用跨架构也不用转译，最大的优点就是你下载了一个砸过壳的 ipa，然后cd 到目录进去之后直接./binary 就能启动。这也意味着你可以直接使用 lldb 附加到这个 binary 进行动态调试——所以现在你只需要一个能分析二进制的工具（开源的也有不少，例如ghidra），以及lldb 就可以完成调试和分析功能。下断点之类的指令请自行学习，所有逻辑都是一样的，唯一不同的是这会你只能在汇编层面下断点了，没有伪代码可以看了。\n改 memory 也简单不少，你可以直接找到 offset 之后\nmemory write \u0026lt;address\u0026gt; hex hex hex hex .... 似乎还有机会可以做自动化处理。\n后记 # 这个逆向过程其实并不难，但是确实是我接触逆向以来的一个比较大的步子。记得那天找了一个旧版的apk，真正逆向出来的时候在深夜，当时逆向出来的时候激动的跳起来，现在想起来真有意思\u0026hellip;\u0026hellip;最后感谢前辈们提供的支持，还有 ida pro，这真的是个好软件。\n","date":"13 November 2024","externalUrl":null,"permalink":"/posts/arcaea_api_reverse/","section":"Posts","summary":"","title":"某立体节奏游戏 API 地址逆向","type":"posts"},{"content":"说起来其实早些时候加入了 开源技术协会，所以对 Linux 也算有了一些了解。后来在暑假拥有了一台 Mac，也算是类 Unix 系统，所以用起来在命令行上熟悉的很快，而且 Mac 的访达（相当于文件资源管理器）也非常方便，所以这里就写一篇简单介绍我的 Mac 的工作流。\n一些有用的软件 # 拿到的第一件事其实是下载了 MacTeX ，也就是 LaTeX 的 Mac 版本。发觉 Mac 安装软件竟然如此简单，dmg 文件类似于 iso 镜像文件，会先挂载，然后我们在安装完成之后可以 unmount。但是有一些 dmg 文件已经做好了 ui 界面，只需要手动的同意同意就可以了。所以安装上没遇到任何困难。安装完成之后删除 dmg 文件，然后在命令行测试\n➜ YinMo19_blog tex -v TeX 3.141592653 (TeX Live 2024) kpathsea version 6.4.0 Copyright 2024 D.E. Knuth. There is NO warranty. Redistribution of this software is covered by the terms of both the TeX copyright and the Lesser GNU General Public License. For more information about these matters, see the file named COPYING and the TeX source. Primary author of TeX: D.E. Knuth. ➜ YinMo19_blog ➜ YinMo19_blog 是 Mac 的 zsh 命令行的命令提示符，表示当前目录为 YinMo19_blog。\n下一件事是安装 python，于是还是到官网下载 dmg 文件，然后点点点就可以了。稍微有一些难度的是接下来的包管理器。熟悉 Linux 就知道 Linux 安装软件依赖都是使用包管理工具来进行安装，例如 apt,npm,yarn,pacman 等等。Mac 使用的是 homebrew 。网上有很多教程，官网的方法可能有些慢，所以我选择清华镜像源。按照清华镜像源的帮助文档一步步跟着配就可以了。注意，homebrew 本体的下载也可以用镜像下载，清华源提供了方式，可以认真看一下。在下载完成之后配置镜像源可以在命令行中使用 vim 编辑 ~/.zshrc 或者 ~/.zprofile。\n这里关于命令行的 zsh/bash 是什么就不介绍了，可以自行查阅。zsh 可以配置 oh-my-zsh 来美化，具体内容可以在网络上查阅。\n了解 Mac # Mac 的访达非常好用。访达本身看上去是一个个文件夹，但是我们可以切换显示的方式。例如我很喜欢分栏 例如上面的图片就是我此时写 blog 的目录。另外还有例如 gallary 的显示方式，用于看图非常合适。而配合命令行来对文件和各种文件进行管理。命令行可以做到几乎所有事情，例如我们想要在这个博客下面查找一个文件，我们可以先使用 find 命令来查找。他的使用和 tldr 文档在上一篇 blog 中已经介绍过了，所以我们这里就不再演示。\n更有意思的是，例如我们可以配合管道符和 grep 来查找文件和各种内容。例如 cat 可以把 file 的内容输出到命令行，然后我们将内容实用管道符传给 grep ，然后就可以查找到相关信息。 我最近使用 minio 来作为一个简单的服务器的存储方案，它需要在环境变量中获取账号密码的值。我们想要查看我们现在的账号密码的值只需要 这样我们就可以轻松的看到之前设置的内容了。相似的，我们在查看ip地址的时候输入\n➜ ~ ifconfig lo0: flags=8049\u0026lt;UP,LOOPBACK,RUNNING,MULTICAST\u0026gt; mtu 16384 options=1203\u0026lt;RXCSUM,TXCSUM,TXSTATUS,SW_TIMESTAMP\u0026gt; inet 127.0.0.1 netmask 0xff000000 inet6 ::1 prefixlen 128 inet6 fe80::1%lo0 prefixlen 64 scopeid 0x1 nd6 options=201\u0026lt;PERFORMNUD,DAD\u0026gt; gif0: flags=8010\u0026lt;POINTOPOINT,MULTICAST\u0026gt; mtu 1280 stf0: flags=0\u0026lt;\u0026gt; mtu 1280 anpi1: flags=8863\u0026lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST\u0026gt; mtu 1500 options=400\u0026lt;CHANNEL_IO\u0026gt; ether d2:5e:23:52:fb:4e media: none status: inactive ... 等等非常多的内容，现在只需要使用\n➜ ~ ifconfig | rg 10 gif0: flags=8010\u0026lt;POINTOPOINT,MULTICAST\u0026gt; mtu 1280 maxage 0 holdcnt 0 proto stp maxaddr 100 timeout 1200 inet 10.250.155.82 netmask 0xffff0000 broadcast 10.250.255.255 inet6 fe80::106b:e1ff:fedc:c0b7%awdl0 prefixlen 64 scopeid 0xd inet6 fe80::106b:e1ff:fedc:c0b7%llw0 prefixlen 64 scopeid 0xe inet6 fe80::7aa:1193:a74b:77ec%utun1 prefixlen 64 scopeid 0x10 utun2: flags=8051\u0026lt;UP,POINTOPOINT,RUNNING,MULTICAST\u0026gt; mtu 1000 inet 100.99.118.11 --\u0026gt; 100.99.118.11 netmask 0xffffffff ➜ ~ rg 是 ripgrep 的缩写，是一个 grep 的可替代工具。\n个人网盘 # 因为现在有很多设备，因此我需要在几台机子上传输数据。因此现在我在 mac 上面部署了一个 alist 服务，可以快速访问。 部署的细节这里就不描述了。我购买了一个域名 yinmo19.top，分别用 file.yinmo19.top 和 cloud.yinmo19.top 绑定了我的 ipv4 和 ipv6 地址。但是默认端口是 5244，因此使用 nginx 将 5244 重定向到 80。这样我们就不需要使用端口号来访问。（80端口是默认的http端口）\n可以介绍的，暂时咕咕不想写的 # mediamtx: 用于将 rtsp 流转成 http 流传输，方便在 obs 中直接通过网络直播的 CLI。\ngit-delta: 看 diff 小工具。\n太多了，so\u0026hellip;.. TOBE CONTINUED~\n","date":"4 September 2024","externalUrl":null,"permalink":"/posts/my_mac_workflow/","section":"Posts","summary":"","title":"我的Mac工作流","type":"posts"},{"content":"在 Arcaea 5.10 版本中更新了 Linkplay 的功能，其中包括了发送一些漂亮可爱的小贴图。这里提供一种简单的方式来获取她们。\n首先，我们在游戏内既然可以点击按钮发送并能否看到这些小贴纸，说明这些图片已经在我们的游戏设备中存在了。一般来说这种游戏资源不可能是在线请求的，而是会直接放在安装包里面（不然 Arcaea 1.3G 的安装包放了什么东西），因此我们可以直接通过拆包来获取。\n游戏安装包大体分为两类，安卓的 apk 和 iOS 的 ipa 文件。这里都可以，我们选择 apk 文件。apk 文件实际上是一个 zip 压缩包，我们可以直接改后缀名然后解压缩，但是为了之后可以更改完再重新打包，我们选择 apktool 工具。\napktool 是什么？官网的介绍是 \u0026ldquo;A tool for reverse engineering Android apk files\u0026rdquo;，即是一个用于反编译和重新编译 apk 文件的命令行工具。他支持全平台使用，安装方法：\nWindows ： 去官网下载软件的压缩包，然后解压之后放在一个你喜欢的地方，把这个文件夹添加到系统路径中。去命令行中测试 apktool ，如果出现了工具本身的 help 文档就说明成功了。\n你可能的问题：（请自行查阅，这或许对你以后的命令行使用有很大的帮助）\n什么是系统路径？ 系统路径是做什么的？ 为什么添加到系统路径之后可以直接在命令行输入 apktool 就可以了？ 如果不添加系统路径我怎么使用 apktool 呢？ MacOS : 如果你的电脑已经拥有了homebrew,那么只需要brew install apktool就可以了。MacOS 是一个 类 Unix 系统，如果你使用了 Mac 电脑，我默认你已经对这些东西都已经有一个清晰的认知。\nLinux : 即然你已经使用了 linux 系统 ，那么怎么安装包已经不需要我再介绍了，一般对于 debian 系的用户就是 sudo apt install apktool ，其他用户自行查阅。\n下载安装包 # 这一步对于安卓用户你怎么玩的游戏就怎么下载，本节主要面向 iOS 用户。在官网 arcaea.lowiro.com/zh 下，他会自动检测你的 ip 地址来提供你的下载途径。对于大陆地区，会直接提供 apk 安装包，而对于大陆外则提供 Google Play 的链接。所以请在下载的时候注意你的 ip 地址位置，不要使用大陆外的代理访问。\napktool d 安装包 # 首先在命令行中进入刚才你下载安装包的那个文件夹。（使用 cd 命令，例如从 /Users/yourname/ 进入到 /Users/yourname/Downloads/可以在命令行输入 cd Downloads）。接下来输入 apktool d Arcaea5_xx_x.apk，来反编译特定版本的 apk 文件。你大概会看到如下输出(我使用 Mac 电脑，但是大体上都是相似的)：\n➜ Downloads apktool d arcaea_5.10.1c.apk I: Using Apktool 2.9.3 on arcaea_5.10.1c.apk I: Loading resource table... I: Decoding file-resources... I: Loading resource table from file: /Users/yinmo19/Library/apktool/framework/1.apk I: Decoding values */* XMLs... I: Decoding AndroidManifest.xml with resources... I: Regular manifest package... I: Baksmaling classes.dex... I: Baksmaling classes2.dex... I: Copying assets and libs... I: Copying unknown files... I: Copying original files... ➜ Downloads 我这里的 ➜ Downloads 是 MacOS 的 zsh 此时本文件夹的提示符。此时我们的文件目录应该大概是这样\n➜ Downloads tree -L 2 . ├── arcaea_5.10.1c │ ├── AndroidManifest.xml │ ├── apktool.yml │ ├── assets │ ├── kotlin │ ├── lib │ ├── original │ ├── res │ ├── smali │ ├── smali_classes2 │ └── unknown └── arcaea_5.10.1c.apk 10 directories, 3 files ➜ Downloads 那么接下来我们就需要去查找我们想要的小贴纸了。一般来说资源文件都会放在 assets 下面，但是即使我们不知道这件事，我们也可以选择查找。这里我们使用 MacOS 和 Linux 中的 find 命令来进行查找。这个命令可以在一个文件夹中按照某种方法来查找文件，如果你不是很熟悉，你可以考虑安装 tldr 包来看看这个命令怎么用。使用 brew install tldr 之后，查看 find 命令。\n➜ Downloads tldr find find Find files or directories under a directory tree, recursively. More information: \u0026lt;https://manned.org/find\u0026gt;. - Find files by extension: find root_path -name \u0026#39;*.ext\u0026#39; - Find files matching multiple path/name patterns: find root_path -path \u0026#39;**/path/**/*.ext\u0026#39; -or -name \u0026#39;*pattern*\u0026#39; - Find directories matching a given name, in case-insensitive mode: find root_path -type d -iname \u0026#39;*lib*\u0026#39; - Find files matching a given pattern, excluding specific paths: find root_path -name \u0026#39;*.py\u0026#39; -not -path \u0026#39;*/site-packages/*\u0026#39; - Find files matching a given size range, limiting the recursive depth to \u0026#34;1\u0026#34;: find root_path -maxdepth 1 -size +500k -size -10M - Run a command for each file (use `{}` within the command to access the filename): find root_path -name \u0026#39;*.ext\u0026#39; -exec wc -l {} \\; - Find all files modified today and pass the results to a single command as arguments: find root_path -daystart -mtime -1 -exec tar -cvf archive.tar {} \\+ - Find empty files (0 byte) or directories and delete them verbosely: find root_path -type f|d -empty -delete -print ➜ Downloads 现在我们不如来查找 maya 也就是我们的妈呀小姐～ 根据上面的命令文档，我们可以简单的使用命令行来查找她。\n➜ Downloads find ./ -iname \u0026#34;*maya*\u0026#34; .//arcaea_5.10.1c/assets/img/1080/arghena/maya_shadow.png .//arcaea_5.10.1c/assets/img/multiplayer/stickers/maya.png .//arcaea_5.10.1c/assets/img/story/entry_maya.png .//arcaea_5.10.1c/assets/img/story/entry_maya_pressed.png .//arcaea_5.10.1c/assets/img/story/entry_maya_boss.png .//arcaea_5.10.1c/assets/img/story/entry_maya_boss_pressed.png .//arcaea_5.10.1c/assets/audio/insight_maya_vanish.wav ➜ Downloads 根据游戏中贴图的使用是在 Linkplay ，显然 .//arcaea_5.10.1c/assets/img/multiplayer/stickers/maya.png 就是我们想要的。 现在我们就已经获得了所有我们想要的图，甚至我们还拥有了全语言版本。\n相似的，我们也可以获取所有角色的图片。她们位于 arcaea_5.10.1c/assets/char/1080 下面。 修改之后的重打包 # 当我们并不拥有一个角色，但是我们很想要本地显示这个角色的时候，我们可以在 arcaea_5.10.1c/assets/char/1080 里面将两个角色的图片的文件名对调，或者使用别的图片替换对应文件，这样在我们本地显示的就会变成我们想要的角色（图片）了，当然云端储存的信息还是原始信息，在好友显示中还是原本的角色。这里我们主要讨论如何将已经反编译后的文档重打包。\n刚才我们使用apktool d了安装包，现在我们将其重新打包起来。使用 apktool b \u0026lt;/path/to/dir\u0026gt; -o \u0026lt;output_apk_name\u0026gt;，这里 b 按照我的理解应该是和 d 对称，表示重新打包（当然这只是我的猜测和我的记忆方案），而 -o 等价于 --output，表示输出。还是一样的，如果你不熟悉，你可以使用 tldr 来看看这个命令如何使用。\n➜ Downloads tldr apktool apktool Reverse engineer APK files. More information: \u0026lt;https://ibotpeaches.github.io/Apktool/\u0026gt;. - Decode an APK file: apktool d path/to/file.apk - Build an APK file from a directory: apktool b path/to/directory - Install and store a framework: apktool if path/to/framework.apk ➜ Downloads 重新打包大概会出现下面的信息。\n➜ Downloads apktool b arcaea_5.10.1c -o ARCAEA_CHANGE.apk I: Using Apktool 2.9.3 I: Checking whether sources has changed... I: Smaling smali folder into classes.dex... I: Checking whether sources has changed... I: Smaling smali_classes2 folder into classes2.dex... I: Checking whether resources has changed... I: Building resources... I: Copying libs... (/lib) I: Copying libs... (/kotlin) I: Building apk file... I: Copying unknown files/dir... I: Built apk into: ARCAEA_CHANGE.apk ➜ Downloads 那么此时我们就拥有了一个新的 APK 文件，我们需要将其安装到安卓手机上。然而安卓手机在安装 apk 文件之前会检查文件的签名和包名。因此我们还需要将其签名（所幸本游戏没有加密、加壳、反调试和签名校验等等）。签名也有命令行工具，然而我们有更简单的方法。将我们生成的 apk 文件发送到你的设备上，在设备上下载一个 mt管理器，它可能会需要你注册登陆，但是那非常简单。在 mt 中找到你生成的 apk 文件。单击它，左下角功能，然后你就会看到一个签名的选项，点击签名然后使用默认签名方案签名之后就可以安装了。\n所说的改包名主要是为了共存。当然 mt 也提供了这个选项。当你想要在一个设备中安装两个一样的安装包，你就需要这个功能，它依然是傻瓜式的点击按钮，所以这里不再说明。至此你已经可以成功获取小贴图和更改图案了。\n这是我的一个特别喜欢草神的朋友改的，效果还不错。 ","date":"2 September 2024","externalUrl":null,"permalink":"/posts/arcaea_pics/","section":"Posts","summary":"","title":"Arcaea 小贴图","type":"posts"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]