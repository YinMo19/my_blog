[{"content":"","date":"7 March 2025","externalUrl":null,"permalink":"/tags/arm-%E6%B1%87%E7%BC%96/","section":"Tags","summary":"","title":"Arm 汇编","type":"tags"},{"content":"Arm 架构是一种 risc 架构，著名的精简指令集。和 x86 架构的汇编思维基本相同，栈帧建立释放，sp 寄存器操作栈，寄存器/内存等等。在区别上主要体现在名称不同。例如对于条件跳转，x86 架构的 jmp 指令，Arm 架构的 b(eq) 指令。x86 的命名明显能视读出 jump，但是 Arm 的汇编则没那么容易看出。所以本文的侧重点可能还会有点奇怪——我更想来看看所有汇编指令的含义，这样记忆起来也会更加深刻。\n其次是为什么学习 Arm 架构汇编而不是 x86 架构？其实学习 x86 架构汇编应该是所有学习汇编的开始，无论从历史角度还是技术，然而事实是笔者学习这个技术的目的是为了逆向工程中对汇编的 patch 更加得心应手。而目前笔者逆向工程的对象一般是\nAndroid Software IOS Software Mac Software 神奇的是这三都是 Arm 64 架构，所以自然而然接触下来也对 Arm 架构有所了解。\n本文仅供初学者阅读，笔者水平很次，如有错误请谅解。本文目标仅仅是在 ida 阅读伪代码之后切换到IDA view的时候能快速定位到汇编，能够知道 patch 什么，怎么 patch。\n在介绍一些命令之前，先讲讲一些汇编的基础。首先汇编本身会有一些比较隐含的规则。可能接触过其他任何编程语言，但没接触过 asm 的初学者会对汇编的返回值感觉奇怪，所有其他语言基本上都是\n... // some code return param; 或者对于 rust 可以不写 return 这个关键字，直接写返回值。\n... // some code param // equals `return param;` 然而在汇编中就是\n... ; some asm code ret 事实上在汇编里面，返回值固定就是第一个寄存器，在 x86 中是 rax，arm64 架构是 x0。也就是这和其他语言有一些很大的区别。在别的语言中单句话的语义是全的。也就是说，我做什么任何事情都是对于这个语句能直接看出来的。就以这个返回值为例，我返回一个值在所有语言里面几乎都是 return something，这个单句实际上表述了返回这个值，而汇编默认返回第一个寄存器；又或者 let a = func(b, c); 一眼就是知道调用了 func ，传入了 b 和 c，返回的值给了 a，而汇编中\nmov x0, x3 // 将 b 的值加载到 x0，假如 b 的值原本在 x3 寄存器 mov x1, x4 // 将 c 的值加载到 x1，假如 c 的值原本在 x4 寄存器 bl func // 调用 func 函数 mov w8, w0 // 假设将返回值存储到 w8 寄存器中 调用函数的默认传入参数就是 x0, x1,...，如果寄存器不够放则调用者负责把超出数量的参数压入栈。从这两个案例中笔者实际上想要表示的意思是，学习汇编不能盯着一行看，因为每一行内容都很短，而其作用会和上下相关。一个值会到处使用，而需要小心这里的东西被那里用到\u0026hellip;.\n另外，例如比较语句，实际上\nif (condition) { do something; } else { do something else; } 这个 if 在汇编中应该也有好几行。我们先简单标注一下位置\nif (condition) { LABEL_1: do something; } else { LABEL_2: do something else; } 因此汇编的大体框架是\ncondition ; 条件判断,例如 cmp r0, r1 beq LABEL_1 ; 如果条件为真，跳转到 LABEL_1 bne LABEL_2 ; 如果条件为假，跳转到 LABEL_2 这里 beq 表示 \u0026ldquo;branch if equal\u0026rdquo; 的缩写，假如条件为真则跳转到 LABEL_1。但是问题是条件是什么？自然是上文紧跟的 cmp,比较的结果直接影响到这里的 beq。如果只盯着这一行看显然是看不懂 beq 到底在做什么了。\n对于函数的入栈出栈在本文还不太需要使用到，下篇将会详述。本篇先讲述一些基础的 Arm 架构的 asm 指令使用。我一向认为，先熟悉这些语法，在熟悉语法之后可以简单 patch 汇编之后，我们才需要研究 sp 的寄存器这些栈帧的事情了，到时候无论是举例子还是其他的都比较简单。下篇或是下下篇，应该会对一个真实的案例逐行分析。\n第一个是 sub 和 subs,这俩一看就知道是减法。具体来说\nsub 是 \u0026ldquo;subtract\u0026rdquo; 的缩写，表示减法。 s 表示 \u0026ldquo;set flags\u0026rdquo;，即设置条件标志位。 使用的参数格式是\nsub/subs \u0026lt;目标寄存器\u0026gt;, \u0026lt;源寄存器1\u0026gt;, \u0026lt;源寄存器2/立即数\u0026gt; \u0026lt;目标寄存器\u0026gt;：存储结果的寄存器。 \u0026lt;源寄存器1\u0026gt;：被减数。 \u0026lt;源寄存器2/立即数\u0026gt;：减数。 需要注意的是subs：与 sub 类似，但会更新条件标志位（如零标志位 Z、负数标志位 N 等）。\n一个简单的案例就是\nsubs w8, w8, #0 将寄存器 w8 的值减去 0，并将结果存回 w8，同时更新条件标志位。 第二个是cset，可以根据条件标志位的值，将目标寄存器设置为 0 或 1。其中cset 是 \u0026ldquo;conditional set\u0026rdquo; 的缩写，表示根据条件设置寄存器。\ncset \u0026lt;目标寄存器\u0026gt;, \u0026lt;条件\u0026gt; \u0026lt;目标寄存器\u0026gt;：存储结果的寄存器。 \u0026lt;条件\u0026gt;：如 ne（不等于）、eq（等于）等。 简单的案例：\ncset w8, ne 如果条件标志位表示“不等于”（ne），则将 w8 设置为 1，否则设置为 0。 第三个 tbnz 是 \u0026ldquo;test bit and branch if nonzero\u0026rdquo; 的缩写。用于测试寄存器中的某一位是否为 1，如果是，则跳转到指定标签。\ntbnz \u0026lt;寄存器\u0026gt;, \u0026lt;位索引\u0026gt;, \u0026lt;标签\u0026gt; \u0026lt;寄存器\u0026gt;：要测试的寄存器。 \u0026lt;位索引\u0026gt;：要测试的位（从 0 开始计数）。 \u0026lt;标签\u0026gt;：如果测试结果为真，则跳转到的目标地址。 简单案例 tbnz w8, #0, LBB0_2 测试 w8 的第 0 位是否为 1，如果是，则跳转到 LBB0_2。 刚才说过 b 是跳转，其实应该说是无条件跳转。对应 x86 中的 jmp label.\nb LBB0_1 表示无条件跳转到 LBB0_1。而b 是 \u0026ldquo;branch\u0026rdquo; 的缩写，表示分支跳转。\n接下来就是神秘命名了。\nldr：从内存加载数据到寄存器。 str：将寄存器中的数据存储到内存。 其中ldr 是 \u0026ldquo;load register\u0026rdquo; 的缩写。str 是 \u0026ldquo;store register\u0026rdquo; 的缩写。有点离谱，但是仔细想想又很合理的感觉。 ldr/str \u0026lt;寄存器\u0026gt;, [\u0026lt;基址寄存器\u0026gt;, #偏移量] \u0026lt;寄存器\u0026gt;：加载或存储的目标寄存器。 \u0026lt;基址寄存器\u0026gt;：内存地址的基址。 #偏移量：相对于基址的偏移。 ldr w8, [sp, #8] str w8, [sp, #4] 从栈指针 sp 偏移 8 的位置加载数据到 w8。 将 w8 的值存储到栈指针 sp 偏移 4 的位置。 与这俩类似的是 stur 和 ldur，加上 u 实际表示的是 \u0026ldquo;unscaled\u0026rdquo;，也就是支持负偏移。用法和上述两者一致，简单案例如下\nstur w8, [x29, #-4] ldur w0, [x29, #-4] 将 w8 存储到 x29 偏移 -4 的位置。 从 x29 偏移 -4 的位置加载数据到 w0。 7. mov # 功能： 将一个寄存器的值复制到另一个寄存器，或将立即数加载到寄存器。 命名原因： mov 是 \u0026ldquo;move\u0026rdquo; 的缩写，表示移动数据。 参数格式： mov \u0026lt;目标寄存器\u0026gt;, \u0026lt;源寄存器/立即数\u0026gt; \u0026lt;目标寄存器\u0026gt;：存储结果的寄存器。 \u0026lt;源寄存器/立即数\u0026gt;：要复制的值。 例子： mov w8, #5 mov x10, x8 将立即数 5 加载到 w8。 将寄存器 x8 的值复制到 x10。 8. mul # 功能： 执行乘法操作，结果存储在目标寄存器中。 命名原因： mul 是 \u0026ldquo;multiply\u0026rdquo; 的缩写，表示乘法。 参数格式： mul \u0026lt;目标寄存器\u0026gt;, \u0026lt;源寄存器1\u0026gt;, \u0026lt;源寄存器2\u0026gt; \u0026lt;目标寄存器\u0026gt;：存储结果的寄存器。 \u0026lt;源寄存器1\u0026gt; 和 \u0026lt;源寄存器2\u0026gt;：两个乘数。 例子： mul w8, w8, w0 将 w8 和 w0 相乘，结果存回 w8。 9. bl # 功能： 调用函数（跳转到指定地址并保存返回地址到 x30）。 命名原因： bl 是 \u0026ldquo;branch with link\u0026rdquo; 的缩写，表示带链接的分支跳转。 参数格式： bl \u0026lt;函数地址\u0026gt; \u0026lt;函数地址\u0026gt;：调用的目标函数。 例子： bl _factorial 调用 _factorial 函数。 10. ret # 功能： 返回到调用者（从 x30 中恢复返回地址）。 命名原因： ret 是 \u0026ldquo;return\u0026rdquo; 的缩写，表示函数返回。 参数格式： ret 无需参数。 总结 # 以上是代码中所有汇编指令的详细解释。每个指令都有其特定的功能和命名逻辑，理解这些指令有助于深入学习汇编语言。如果有其他疑问，欢迎继续提问！\n","date":"7 March 2025","externalUrl":null,"permalink":"/posts/arm_learn_1/","section":"Posts","summary":"","title":"Arm 汇编 学习小记(1)","type":"posts"},{"content":"","date":"7 March 2025","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"7 March 2025","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"7 March 2025","externalUrl":null,"permalink":"/","section":"YinMo19's Blog","summary":"","title":"YinMo19's Blog","type":"page"},{"content":"今天也是继续写很刑的话题。这次是笔者目前在读的某学校的教务 app。此 app 之前的版本毫无安全可言，没有任何校验等等\u0026hellip;. 直到最近才勉强更新了一个版本。更新了一些小功能云云不必多谈，但是究其根本，居然换了一套 app 开发框架。简单一看，是国人开发的 uniapp 。\n本来是没有任何想要逆向这个软件的，因为任何有意义一点的操作都可以直接去给 web 端抓包获得，但是一个朋友给我看到\u0026hellip;.\n我当即就惊了，怎么大家都可以就他这个不可以。当然线下我肯定是狠狠嘲笑他被华为卡脖子了（华为平板），但是究其根本肯定是软件误检测了模拟器环境。因此尝试使用逆向改掉模拟器检测逻辑就显得意义重大。\n于是我进行了一点点尝试。我在我的 mac 电脑上安装了一个app store里面的本研，但是发现——不能运行在 root/越狱 环境内。mac 上面的软件数据确实可以看得一清二楚，算越狱环境确实是情有可原。但是我们还得去破嘛。\n这时候就发现，上面那图居然还有一个语法错误。\n应用被不能运行到模拟器 什么叫做 被不能 运行到模拟器\u0026hellip;\u0026hellip;. 这就是国产 api 吗\u0026hellip;.\n但是这处也直接暴露了开发框架——我们可以在 uniapp-客户端安全API 中找到 于是我们就可以直接确定这是 js 层的校验了。不需要去 so 里面patch。 IDA 启动失败! 然后我们在 ios 这里找找。进入\n!w /Applications/本研教学服务.app/Wrapper/HBuilder.app at 03:01:50 PM \u0026gt; ls AppIcon60x60@2x.png Pandora control.xml uni_uts_toast_error.png Assets.car PandoraApi.bundle dcloud_logo@2x.png uni_uts_toast_success.png Base.lproj PkgInfo dcloud_logo@3x.png unincomponents.ttf Frameworks SC_Info en.lproj weex-polyfill.js HBuilder _CodeSignature uni-jsframework-vue3.js weexUniJs.js Info.plist __uniappes6.js uni-jsframework.js zh-Hans.lproj 大概是一些打包信息。我们假设这条消息没有被混淆，那么\nweexUniJs.js:var plusContext={};const DC_INTERVAL_ID=\u0026#34;__dc__Interval_id__\u0026#34;;var __dc__setInterval=function(e,t){return setIntervalWeex(DC_INTERVAL_ID,e,t)},__dc__clearInterval=function(e){clearIntervalWeex(DC_INTERVAL_ID,e)};plusContext.setInterval=__dc__setInterval,plusContext.clearInterval=__dc__clearInterval,plusContext.setTimeout=function(e,t){var n=arguments.length,i=Array(2\u0026lt;n?n-2:0);for(idx=2;idx\u0026lt;n;idx++)i[idx-2]=arguments[idx];var o=__dc__setInterval(function(){__dc__clearInterval(o),e.apply(void 0,i)},t=t||1);return o},plusContext.clearTimeout=__dc__clearInterval,plusContext.getLocationHerf=function(e){return e.weex.config.bundleUrl};var PlusObject=function(plusContext,param){plusContext.__param__=param;var dc_plusobjects={},dc_plusMouldes={};function PlusObject(e,t){for(var n in this.weex=t,this.weex_instance_id=e,this.__HtMl_Id__,this.__io__dc_vue_call_exec_sync=\u0026#34;undefined\u0026#34;!=typeof global\u0026amp;\u0026amp;global.__io__dc_vue_call_exec_sync,this.__io__dc_vue_call_exec=\u0026#34;undefined\u0026#34;!=typeof global\u0026amp;\u0026amp;global.__io__dc_vue_call_exec,this.weexBridge=t.requireModule(\u0026#34;plus\u0026#34;),this.globalEvent=t.requireModule(\u0026#34;globalEvent\u0026#34;),dc_plusMouldes){var i;this[n]||(i=dc_plusMouldes[n](plusContext,this,this.require,param[n]))\u0026amp;\u0026amp;(this[n]=i)}}return PlusObject.prototype.updateConfigInfo=function(){var e=this.weexBridge.getConfigInfo();if(e)for(var t in\u0026#34;string\u0026#34;==typeof e\u0026amp;\u0026amp;(e=JSON.parse(e)),this.__WebVieW_Id__=e.__WebVieW_Id__,this.__HtMl_Id__=e.__HtMl_Id__,e){var n=this[t];if(\u0026#34;object\u0026#34;==typeof n\u0026amp;\u0026amp;e[t])if(n.updateInfo)n.updateInfo(e[t]);else{var i,o=e[t];for(i in o)n[i]=n[i]||o[i]}}},PlusObject.prototype.require=function(e){var t;return this[e]||(t=dc_plusMouldes[e](plusContext,this,this.require,param[e]))\u0026amp;\u0026amp;(this[e]=t),this[e]},PlusObject.prototype.importMoudle=function(name){if(this[name])return this[name];var script=t............ 一查发现一个巨大的 js 居然是一行\u0026hellip; 没眼看，但是看到这个最让人怀疑的weexUniJs.js。进入查看，格式化一下，发现\nisSimulator: function () { return bridge.execSync(_PLUSNAME, \u0026#39;isSimulator\u0026#39;, []) }, 以及上面有一个 isroot。我们直接将两个函数的返回值改为 false之后， 在mac上就可以直接运行了。 接下来就是 android 的部分了。\n首先要先确定有没有签名校验。要是有签名校验可就麻烦一些了，只能先破掉这个再谈其他。结果测试一下，不但没有签名校验，也没有反debug校验\u0026hellip;.. 安全了但没有完全安全，于是用 apktool 反编译之后，查找到unknown/io/dcloud/weeUniJs.js，\nisRoot: function () { return ( plus.tools.ANDROID != plus.tools.platform \u0026amp;\u0026amp; bridge.execSync(_PLUSNAME, \u0026#39;isRoot\u0026#39;, []) ) }, isSimulator: function () { return bridge.execSync(_PLUSNAME, \u0026#39;isSimulator\u0026#39;, []) }, 将两个函数返回值改为 false，重新打包就可以了。\n小插曲 # 最开始根本没发现，尝试了反编译 smali，手动patch smali\u0026hellip;. 完全不熟悉js层和java层的内容。浪费了好多时间hhh\n","date":"3 March 2025","externalUrl":null,"permalink":"/posts/hitsz_by_rev_root/","section":"Posts","summary":"","title":"本研教学服务-反root/模拟器校验","type":"posts"},{"content":"","date":"13 November 2024","externalUrl":null,"permalink":"/tags/binary-reverse/","section":"Tags","summary":"","title":"Binary Reverse","type":"tags"},{"content":"","date":"13 November 2024","externalUrl":null,"permalink":"/tags/cfb/","section":"Tags","summary":"","title":"Cfb","type":"tags"},{"content":"","date":"13 November 2024","externalUrl":null,"permalink":"/tags/crypto/","section":"Tags","summary":"","title":"Crypto","type":"tags"},{"content":" 🔐 技术型隐藏页面 · 验证密钥 解锁内容 验证未通过，请重试\n这篇文章是关于逆向某游戏的，所以先来点\u0026hellip;\n本文所写内容仅供学习交流，作者对于读者所做的任何行为概不负责，如果跟着本文所写内容操作，您需要对自己的行为导致的任何后果负责！\nOk. 总所周知，某3d立体节奏游戏作为一个在线游戏（虽然只有登陆上传下载还有 LINK 的时候需要用到网络），那么必然存在一个服务器。而且在游戏本体中必然直接硬编码了一个游戏地址，否则游戏的数据就无法对着服务器发送。\n在早期版本并没有对这个服务器地址进行什么操作，直接使用明文写在二进制中。但是在3.6.0左右进行了一次比较大的改动，对地址进行了加密。在4.5.0左右版本又对加密算法进行了一些小更新。因此本文主要关于逆向这个加密算法。\n之所以逆向这个服务器地址，当然是因为我们想要搭建一个自己的私服。所以在讲述这个过程之前先让我首先对 Lost-MSth大佬表示最深刻的敬意，是他手把手教我如何操作，并且给我很多支持（在这个过程中我犯的傻不计其数）。我的私服程序来源于他发布在 Github 上的 Arcaea-Server。\n本文参考了\nArcaea-Server 看雪论坛：[原创] 某 iOS 遊戲抓包、修改 fishiat 的 blog Android 无 ROOT 权限动态调试 (By Lost) 什么是私服，怎么搭建 # 这个其实完全不应该由我来说，在 Arcaea-Server 中已经有良好的文档，请一个字一个字阅读。这个仓库的 Wiki 可以说微言大义，错过了任何内容都是损失。\n但是我们想讲讲关于私服本身。下面是一张简单的结构图 这张图简单的展示了其的网络结构。客户端通过网络和官方服务器通信。这种通信基于 https,并且这游戏还做了双端证书校验（一般的https服务仅仅校验服务器证书）防止被抓包。中间的技术细节就不展开。我们的目标是搭建一个自己的服务器，而让一个修改后的私服客户端和我们的服务器通信。可以想到的第一种方法是 我们首先通过代理服务器来作为中间链接，然后让代理服务器劫持所有指向官方服务器的流量，然后将其转发，或者说重定向到你自己的服务器。 但是这种方法相当于每个人想要玩到你的服务器都需要这样做，不提这样做的实现是否真的可行，这样对于玩家显然一点也不友好。\n那有没有什么做法干净又卫生呢？ # 那我们回到最开始的路径。 我们在开头提到过，既然要访问到官方服务器，那么一定在客户端写死了服务器的地址。那么有没有可能我们可以直接更改客户端来让客户端直接访问我们的服务器呢？ 这就是本文的目的了。\n关于修改地址 # 首先我们要先来确定加密的方式和加密的位置。由于更高版本的客户端二进制中加入了更多的混淆，因此我们选一个比较好逆向的客户端。我选取的是4.5.x版本的一个客户端。当然你选什么都一样，只是后面的版本inline function 太狠了，一个函数长达两万行你的电脑可能需要分析得很久，反正算法没改选一个早期没混淆那么多的分析起来快点。下面当然是基于4.5.x版本的一个客户端的案例，我讲讲如果你选取别的客户端要怎么分析。 如果你 decompile 的时候发现因为太长无法反编译，那么你可以在ida 的 edit-plugins-hex ray decompiler options中找到 analyse option 3，把第一个改到 1024 第二个改到 256，然后重新反编译就可以了。另外高版本你可能可以选择 /bundle_download/ api 的前面进行分析，因为这个是最初访问的 api。另外高版本的 arm 架构的 while offset in 16{ xor } 行为可能会被编译期自动向量化为一条 neon 指令，每 16 bytes作为一个 int128 直接进行 veorq_s8，因此断点打在哪里就需要你自己分析了。\n6.x 版本api 有了一个 break change!\nauth 部分独立开了。 以往的 api 完全在 https://arcapi-v3.lowiro.com/\u0026lt;endpoint\u0026gt; 内，目前 auth 部分单独走 https://auth.lowiro.com/ 。但是加密手段完全一致，你依然可以根据下文的手段进行分析，只是 48bytes 变成了 36bytes 罢了。\n继续对低版本的分析，首先我们通过 apktool 来将其拆开。我们需要更改的是其下的 lib/armeabi-v7a/libcocos2dcpp.so 文件。我们选取32位，它的逆向更简单，而且动态调试也更加简单。不要忘记删除 lib/arm64-v8a/ 文件夹。否则手机会自动使用64位版本的二进制文件。\n我的所有思路参考看雪论坛：[原创] 某 iOS 遊戲抓包、修改，当然这篇文章中的地址已经不适用了，因为这篇文章是给4.2.x 使用的，上文提到4.5.x修改了加密密钥。\n使用 ida pro 打开这个文件。IDA PRO 是一款优秀的反汇编工具，这里就不赘述了。 选择默认选项（ida已经帮我们识别它的类型了（linux elf 二进制动态链接库文件），打开之后 ida 会自动解析这个二进制文件，解析速度取决于文件大小，不过我们可以先进行操作，操作的时候解析过程会先停止优先保证我们的操作流畅度。我们可以先搜索字符串（快捷键 shift-F12） auth/login。之所以搜索这个，是因为登陆必须对服务器进行请求，一定会涉及到服务器地址，这毋庸置疑。 搜索到这个字符串之后我们可以按 X 键查看引用，直接跳转到第一个引用的地方。 跳转到的地方可能会出现一些框图，这是代码的结构图，主要是程序的结构。可以按空格退回汇编界面。接下来按 F5 可以查看函数的反编译的伪c代码。 我们可以读代码，并按n对变量名称进行修改。（在编译过程中编译器会对变量名重命名，因此我们变量名信息丢失之后 ida 只能使用 v1v2 这样的变量来表示。如果我们阅读之后可以确定含义我们可以对其重命名来明晰代码）\n根据分析我们大概可以确定（其实是根据前人的经验）代码结构如下 其中 idx 可以查看引用看看赋值位置 而又有 显然 idx 最开始是16，然后大循环之后赋值给v1073，然后v1073没经过任何修改又给idx赋值。在后面的 while 循环中作为递减变量控制循环刚好进行16次。阅读代码，会发现上面有一串非常长的代码，几乎毫无可阅读性。 从大佬的文章大概可以知道这是一种 CFB 加密，也就是上一次加密的结果再通过某种算法获得下一次加密的密钥。而根据 idx 我们大概知道一次加密16个字节，根据实际的地址长短\nhttps://arcapi-v3.lowiro.com/\u0026lt;api_endpoint\u0026gt; 是分成三次加密。而不到48字节则在最后补\\0x00。因此我们不能拿到算法本身，我们就只能通过动态调试，通过修改内存值，再拿到每一次的XOR KEY来获取结果。\n总结一下，大概算法是这样的：\ndef get_next_xor_key(last_addr: bytes, last_xor_key): # do something weird # calculate next xor key return next_xor_key for i in range(3): addr = \u0026#34;aosiaosciaqwu12hoichoaichoaihcoccqwocihqoqwdwqwd\u0026#34;[16 * i : 16 * (i + 1)] for j in range(16): next_addr = next_xor_key[j] ^ addr[j] next_xor_key = get_next_xor_key(next_addr, next_xor_key) 现在我们有 a^b = c, c^b = a^b^b = a ，所以我们可以通过直接通过拿到内存中的 xor_key 和我们想要的地址直接计算出加密之后的地址。而加密的地址和密钥再 XOR 之后即可获取到解密的结果。算法具体请参照看雪论坛：[原创] 某 iOS 遊戲抓包、修改。\n动态调试 # 在现在 root 手机变得相对更加困难，更取决于手机厂商是否让root，而非是自己的技术。但是这游戏并没有关于反 debug 的校验，所以我们只需要通过修改安装包，然后直接通过 run-as 命令来控制 debug 就可以实现无 root 权限调试。\n关于这一块的内容请阅读Android 无 ROOT 权限动态调试 (By Lost) 这里补充说明一下，在 ida 9.0 mac版本上的 android_server 无后缀是 64位的，有32后缀的是32位的，和教程中的不一样，需要注意。\n我们将更改好的软件传输到手机上安装云云\u0026hellip;. (推荐直接使用 adb push xxx.apk /storage/emulated/0/ 应该至少有30-40mb/s 速度) 然后将端口转发设置好，并启动ida的服务器。 这里我没有演示如何传入服务器文件和chmod改777权限部分，还是请参照 Lost-MSth大佬的blog Android 无 ROOT 权限动态调试 (By Lost)。\n现在我们应该在哪里下断点呢？显然是 在while循环之前，while循环进行 xor 加密，在此之前刚好拿到上一次加密结束的密钥，我们可以直接对着我们想要的结果和密钥 xor 之后写入对应的内存，然后下一次加密就会使用这个新的地址计算下一次的 xor key。\n显然这里第一次计算的xor key是固定的 25 42 38 06 4B 6E 4B 3B 63 85 43 CD E6 DF BB 6F （至少到5.10.6还是）。因此我们写一个小程序用于计算加密结果。\n# 你的地址 http(s)://ip:port(domain:port)/\u0026lt;api_endpoint\u0026gt; api_prefix = \u0026#34;https://test.yinmo19.top/natsugakuru/30/\u0026#34; if len(api_prefix) \u0026lt; 48: api_prefix += \u0026#34;\\x00\u0026#34; * (48 - len(api_prefix)) b = bytes.fromhex(\u0026#34;25 42 38 06 4B 6E 4B 3B 63 85 43 CD E6 DF BB 6F\u0026#34;) prefix = api_prefix[:16] prefix = bytes.fromhex(prefix.encode().hex()) print(bytes(i ^ j for i, j in zip(prefix, b[:16])).hex(\u0026#34; \u0026#34;)) b = bytes.fromhex(\u0026#34;25 42 38 06 4B 6E 4B 3B 63 85 43 CD E6 DF BB 6F\u0026#34;) # 获取到第二个 xor_key 之后填入 prefix = api_prefix[16:32] prefix = bytes.fromhex(prefix.encode().hex()) print(bytes(i ^ j for i, j in zip(prefix, b[:16])).hex(\u0026#34; \u0026#34;)) b = bytes.fromhex(\u0026#34;25 42 38 06 4B 6E 4B 3B 63 85 43 CD E6 DF BB 6F\u0026#34;) # 获取到第三个 xor_key 之后填入 prefix = api_prefix[32:] prefix = bytes.fromhex(prefix.encode().hex()) print(bytes(i ^ j for i, j in zip(prefix, b[:16])).hex(\u0026#34; \u0026#34;)) 现在进 debugger 设置一下 我们就可以选择附加进程 (Attach to Process) ，手机上启动程序，在 ida 中附加进程的可选项应该可以看到一个[32] 包名的选项 接下来应该会刷入一堆东西，接下来如果需要选择，就选 same。这个问题是问你在电脑上调试的内容和手机软件里面的是否一样，自然一样。然后点击上方的运行按钮，现在卡住的软件应该动起来了。随便在手机上Login输入点东西，然后按一下 Login，这个时候应该会卡住，而ida跳到刚才打的断点的位置。 现在我们双击encrypt_addr_this跳转到 看到 4d 36 4c 76...(M6Lv...) 就说明这个确实是地址（这个是地址的开头，对应 http 的加密结果）。右键选择关联到(synchronize with) hex， 这样下面的hex也对应关联到对应位置。我们直接选择菜单栏中的 改bytes，刚好一次可以改16个。我们将我们已经知道的第一个16比特直接写入。 看到橙色的修改即表示修改成功。（可以按一下 xor_key 看看是否和上文说的第一个 xor_key 一致）然后按运行个运行到下一个断点位置（还是同一个位置）。\n接下来应该先看xor_key_addr ，双击查看内存地址和值 刚好是B8开头的这一行 B8 97 5E AD FC B7 F0 EF F1 A0 1E 5A 36 4D C1 AA 。我们直接将整行复制下来，粘贴到上面的python脚本中的第二个位置，运行可以得到加密地址的中间16字节 d5 f8 6f 94 d2 c3 9f 9f de ce 7f 2e 45 38 a6 cb，和上面操作一致，写入地址。接下来就可以重复第三次操作，拿到最后一次的 xor_key，加密地址。最后将三次获取的内容拼接起来，一共48字节。以后想要开私服只需要替换掉二进制文件中的对应地址就可以了。\n这里我提供一个替换小程序，如果有需要可以改改用。\nimport os def generate_patched_so( filename, before: bytes, to_replace: bytes, suffix: str = \u0026#34;arcapi\u0026#34; ): if not os.path.exists(filename): print(f\u0026#34;Didn\u0026#39;t find {filename}, skipping patch generation\u0026#34;) return with open(filename, \u0026#34;rb\u0026#34;) as f: data = f.read() if data.find(to_replace) != -1: print(f\u0026#34;{filename} looks to be already patched :)\u0026#34;) return if data.find(before) == -1: print(f\u0026#34;{filename} doesn\u0026#39;t contain the original modulus.\u0026#34;) return data = data.replace(before, to_replace) patched_filename = f\u0026#34;{filename}.{suffix}\u0026#34; with open(patched_filename, \u0026#34;wb\u0026#34;) as f: f.write(data) print( f\u0026#34;Generated address patch to {patched_filename}! To apply the patch, replace the original file with the patched file.\u0026#34; ) origin = bytes.fromhex( \u0026#34;4d364c763854641402f720ac96b696198bb932c28bde8280cad46122473cf0c63c63f8359caab6e6a6d2d4eab1db7d93\u0026#34; ) replace_addr = bytes.fromhex( \u0026#34;owoqowoqciwqociowqhoiqicoiqocuwqcoqioucoqcoqwfhiqohfcowqcjwbfuiocqwhfbwusofihqwqwoifhqohwoqhqhfq\u0026#34; ) # 替换成你的内容 generate_patched_so(\u0026#34;libcocos2dcpp.so\u0026#34;, origin, replace_addr) 如果找到了对应部分则会在本地目录下生成一份补丁文件libcocos2dcpp.so.arcapi，将这个文件直接覆盖原文件即可。\ncp libcocos2dcpp.so.arcapi libcocos2dcpp.so 那么就完成了。\n后记 # 这个逆向过程其实并不难，但是确实是我接触逆向以来的一个比较大的步子。记得那天找了一个旧版的apk，真正逆向出来的时候在深夜，当时逆向出来的时候激动的跳起来，现在想起来真有意思\u0026hellip;\u0026hellip;最后感谢前辈们提供的支持，还有 ida pro，这真的是个好软件。\n","date":"13 November 2024","externalUrl":null,"permalink":"/posts/arcaea_api_reverse/","section":"Posts","summary":"","title":"某立体节奏游戏 API 地址逆向","type":"posts"},{"content":"说起来其实早些时候加入了 开源技术协会，所以对 Linux 也算有了一些了解。后来在暑假拥有了一台 Mac，也算是类 Unix 系统，所以用起来在命令行上熟悉的很快，而且 Mac 的访达（相当于文件资源管理器）也非常方便，所以这里就写一篇简单介绍我的 Mac 的工作流。\n一些有用的软件 # 拿到的第一件事其实是下载了 MacTeX ，也就是 LaTeX 的 Mac 版本。发觉 Mac 安装软件竟然如此简单，dmg 文件类似于 iso 镜像文件，会先挂载，然后我们在安装完成之后可以 unmount。但是有一些 dmg 文件已经做好了 ui 界面，只需要手动的同意同意就可以了。所以安装上没遇到任何困难。安装完成之后删除 dmg 文件，然后在命令行测试\n➜ YinMo19_blog tex -v TeX 3.141592653 (TeX Live 2024) kpathsea version 6.4.0 Copyright 2024 D.E. Knuth. There is NO warranty. Redistribution of this software is covered by the terms of both the TeX copyright and the Lesser GNU General Public License. For more information about these matters, see the file named COPYING and the TeX source. Primary author of TeX: D.E. Knuth. ➜ YinMo19_blog ➜ YinMo19_blog 是 Mac 的 zsh 命令行的命令提示符，表示当前目录为 YinMo19_blog。\n下一件事是安装 python，于是还是到官网下载 dmg 文件，然后点点点就可以了。稍微有一些难度的是接下来的包管理器。熟悉 Linux 就知道 Linux 安装软件依赖都是使用包管理工具来进行安装，例如 apt,npm,yarn,pacman 等等。Mac 使用的是 homebrew 。网上有很多教程，官网的方法可能有些慢，所以我选择清华镜像源。按照清华镜像源的帮助文档一步步跟着配就可以了。注意，homebrew 本体的下载也可以用镜像下载，清华源提供了方式，可以认真看一下。在下载完成之后配置镜像源可以在命令行中使用 vim 编辑 ~/.zshrc 或者 ~/.zprofile。\n这里关于命令行的 zsh/bash 是什么就不介绍了，可以自行查阅。zsh 可以配置 oh-my-zsh 来美化，具体内容可以在网络上查阅。\n了解 Mac # Mac 的访达非常好用。访达本身看上去是一个个文件夹，但是我们可以切换显示的方式。例如我很喜欢分栏 例如上面的图片就是我此时写 blog 的目录。另外还有例如 gallary 的显示方式，用于看图非常合适。而配合命令行来对文件和各种文件进行管理。命令行可以做到几乎所有事情，例如我们想要在这个博客下面查找一个文件，我们可以先使用 find 命令来查找。他的使用和 tldr 文档在上一篇 blog 中已经介绍过了，所以我们这里就不再演示。\n更有意思的是，例如我们可以配合管道符和 grep 来查找文件和各种内容。例如 cat 可以把 file 的内容输出到命令行，然后我们将内容实用管道符传给 grep ，然后就可以查找到相关信息。 我最近使用 minio 来作为一个简单的服务器的存储方案，它需要在环境变量中获取账号密码的值。我们想要查看我们现在的账号密码的值只需要 这样我们就可以轻松的看到之前设置的内容了。相似的，我们在查看ip地址的时候输入\n➜ ~ ifconfig lo0: flags=8049\u0026lt;UP,LOOPBACK,RUNNING,MULTICAST\u0026gt; mtu 16384 options=1203\u0026lt;RXCSUM,TXCSUM,TXSTATUS,SW_TIMESTAMP\u0026gt; inet 127.0.0.1 netmask 0xff000000 inet6 ::1 prefixlen 128 inet6 fe80::1%lo0 prefixlen 64 scopeid 0x1 nd6 options=201\u0026lt;PERFORMNUD,DAD\u0026gt; gif0: flags=8010\u0026lt;POINTOPOINT,MULTICAST\u0026gt; mtu 1280 stf0: flags=0\u0026lt;\u0026gt; mtu 1280 anpi1: flags=8863\u0026lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST\u0026gt; mtu 1500 options=400\u0026lt;CHANNEL_IO\u0026gt; ether d2:5e:23:52:fb:4e media: none status: inactive ... 等等非常多的内容，现在只需要使用\n➜ ~ ifconfig | rg 10 gif0: flags=8010\u0026lt;POINTOPOINT,MULTICAST\u0026gt; mtu 1280 maxage 0 holdcnt 0 proto stp maxaddr 100 timeout 1200 inet 10.250.155.82 netmask 0xffff0000 broadcast 10.250.255.255 inet6 fe80::106b:e1ff:fedc:c0b7%awdl0 prefixlen 64 scopeid 0xd inet6 fe80::106b:e1ff:fedc:c0b7%llw0 prefixlen 64 scopeid 0xe inet6 fe80::7aa:1193:a74b:77ec%utun1 prefixlen 64 scopeid 0x10 utun2: flags=8051\u0026lt;UP,POINTOPOINT,RUNNING,MULTICAST\u0026gt; mtu 1000 inet 100.99.118.11 --\u0026gt; 100.99.118.11 netmask 0xffffffff ➜ ~ rg 是 ripgrep 的缩写，是一个 grep 的可替代工具。\n个人网盘 # 因为现在有很多设备，因此我需要在几台机子上传输数据。因此现在我在 mac 上面部署了一个 alist 服务，可以快速访问。 部署的细节这里就不描述了。我购买了一个域名 yinmo19.top，分别用 file.yinmo19.top 和 cloud.yinmo19.top 绑定了我的 ipv4 和 ipv6 地址。但是默认端口是 5244，因此使用 nginx 将 5244 重定向到 80。这样我们就不需要使用端口号来访问。（80端口是默认的http端口）\n可以介绍的，暂时咕咕不想写的 # mediamtx: 用于将 rtsp 流转成 http 流传输，方便在 obs 中直接通过网络直播的 CLI。\ngit-delta: 看 diff 小工具。\n太多了，so\u0026hellip;.. TOBE CONTINUED~\n","date":"4 September 2024","externalUrl":null,"permalink":"/posts/my_mac_workflow/","section":"Posts","summary":"","title":"我的Mac工作流","type":"posts"},{"content":"在 Arcaea 5.10 版本中更新了 Linkplay 的功能，其中包括了发送一些漂亮可爱的小贴图。这里提供一种简单的方式来获取她们。\n首先，我们在游戏内既然可以点击按钮发送并能否看到这些小贴纸，说明这些图片已经在我们的游戏设备中存在了。一般来说这种游戏资源不可能是在线请求的，而是会直接放在安装包里面（不然 Arcaea 1.3G 的安装包放了什么东西），因此我们可以直接通过拆包来获取。\n游戏安装包大体分为两类，安卓的 apk 和 iOS 的 ipa 文件。这里都可以，我们选择 apk 文件。apk 文件实际上是一个 zip 压缩包，我们可以直接改后缀名然后解压缩，但是为了之后可以更改完再重新打包，我们选择 apktool 工具。\napktool 是什么？官网的介绍是 \u0026ldquo;A tool for reverse engineering Android apk files\u0026rdquo;，即是一个用于反编译和重新编译 apk 文件的命令行工具。他支持全平台使用，安装方法：\nWindows ： 去官网下载软件的压缩包，然后解压之后放在一个你喜欢的地方，把这个文件夹添加到系统路径中。去命令行中测试 apktool ，如果出现了工具本身的 help 文档就说明成功了。\n你可能的问题：（请自行查阅，这或许对你以后的命令行使用有很大的帮助）\n什么是系统路径？ 系统路径是做什么的？ 为什么添加到系统路径之后可以直接在命令行输入 apktool 就可以了？ 如果不添加系统路径我怎么使用 apktool 呢？ MacOS : 如果你的电脑已经拥有了homebrew,那么只需要brew install apktool就可以了。MacOS 是一个 类 Unix 系统，如果你使用了 Mac 电脑，我默认你已经对这些东西都已经有一个清晰的认知。\nLinux : 即然你已经使用了 linux 系统 ，那么怎么安装包已经不需要我再介绍了，一般对于 debian 系的用户就是 sudo apt install apktool ，其他用户自行查阅。\n下载安装包 # 这一步对于安卓用户你怎么玩的游戏就怎么下载，本节主要面向 iOS 用户。在官网 arcaea.lowiro.com/zh 下，他会自动检测你的 ip 地址来提供你的下载途径。对于大陆地区，会直接提供 apk 安装包，而对于大陆外则提供 Google Play 的链接。所以请在下载的时候注意你的 ip 地址位置，不要使用大陆外的代理访问。\napktool d 安装包 # 首先在命令行中进入刚才你下载安装包的那个文件夹。（使用 cd 命令，例如从 /Users/yourname/ 进入到 /Users/yourname/Downloads/可以在命令行输入 cd Downloads）。接下来输入 apktool d Arcaea5_xx_x.apk，来反编译特定版本的 apk 文件。你大概会看到如下输出(我使用 Mac 电脑，但是大体上都是相似的)：\n➜ Downloads apktool d arcaea_5.10.1c.apk I: Using Apktool 2.9.3 on arcaea_5.10.1c.apk I: Loading resource table... I: Decoding file-resources... I: Loading resource table from file: /Users/yinmo19/Library/apktool/framework/1.apk I: Decoding values */* XMLs... I: Decoding AndroidManifest.xml with resources... I: Regular manifest package... I: Baksmaling classes.dex... I: Baksmaling classes2.dex... I: Copying assets and libs... I: Copying unknown files... I: Copying original files... ➜ Downloads 我这里的 ➜ Downloads 是 MacOS 的 zsh 此时本文件夹的提示符。此时我们的文件目录应该大概是这样\n➜ Downloads tree -L 2 . ├── arcaea_5.10.1c │ ├── AndroidManifest.xml │ ├── apktool.yml │ ├── assets │ ├── kotlin │ ├── lib │ ├── original │ ├── res │ ├── smali │ ├── smali_classes2 │ └── unknown └── arcaea_5.10.1c.apk 10 directories, 3 files ➜ Downloads 那么接下来我们就需要去查找我们想要的小贴纸了。一般来说资源文件都会放在 assets 下面，但是即使我们不知道这件事，我们也可以选择查找。这里我们使用 MacOS 和 Linux 中的 find 命令来进行查找。这个命令可以在一个文件夹中按照某种方法来查找文件，如果你不是很熟悉，你可以考虑安装 tldr 包来看看这个命令怎么用。使用 brew install tldr 之后，查看 find 命令。\n➜ Downloads tldr find find Find files or directories under a directory tree, recursively. More information: \u0026lt;https://manned.org/find\u0026gt;. - Find files by extension: find root_path -name \u0026#39;*.ext\u0026#39; - Find files matching multiple path/name patterns: find root_path -path \u0026#39;**/path/**/*.ext\u0026#39; -or -name \u0026#39;*pattern*\u0026#39; - Find directories matching a given name, in case-insensitive mode: find root_path -type d -iname \u0026#39;*lib*\u0026#39; - Find files matching a given pattern, excluding specific paths: find root_path -name \u0026#39;*.py\u0026#39; -not -path \u0026#39;*/site-packages/*\u0026#39; - Find files matching a given size range, limiting the recursive depth to \u0026#34;1\u0026#34;: find root_path -maxdepth 1 -size +500k -size -10M - Run a command for each file (use `{}` within the command to access the filename): find root_path -name \u0026#39;*.ext\u0026#39; -exec wc -l {} \\; - Find all files modified today and pass the results to a single command as arguments: find root_path -daystart -mtime -1 -exec tar -cvf archive.tar {} \\+ - Find empty files (0 byte) or directories and delete them verbosely: find root_path -type f|d -empty -delete -print ➜ Downloads 现在我们不如来查找 maya 也就是我们的妈呀小姐～ 根据上面的命令文档，我们可以简单的使用命令行来查找她。\n➜ Downloads find ./ -iname \u0026#34;*maya*\u0026#34; .//arcaea_5.10.1c/assets/img/1080/arghena/maya_shadow.png .//arcaea_5.10.1c/assets/img/multiplayer/stickers/maya.png .//arcaea_5.10.1c/assets/img/story/entry_maya.png .//arcaea_5.10.1c/assets/img/story/entry_maya_pressed.png .//arcaea_5.10.1c/assets/img/story/entry_maya_boss.png .//arcaea_5.10.1c/assets/img/story/entry_maya_boss_pressed.png .//arcaea_5.10.1c/assets/audio/insight_maya_vanish.wav ➜ Downloads 根据游戏中贴图的使用是在 Linkplay ，显然 .//arcaea_5.10.1c/assets/img/multiplayer/stickers/maya.png 就是我们想要的。 现在我们就已经获得了所有我们想要的图，甚至我们还拥有了全语言版本。\n相似的，我们也可以获取所有角色的图片。她们位于 arcaea_5.10.1c/assets/char/1080 下面。 修改之后的重打包 # 当我们并不拥有一个角色，但是我们很想要本地显示这个角色的时候，我们可以在 arcaea_5.10.1c/assets/char/1080 里面将两个角色的图片的文件名对调，或者使用别的图片替换对应文件，这样在我们本地显示的就会变成我们想要的角色（图片）了，当然云端储存的信息还是原始信息，在好友显示中还是原本的角色。这里我们主要讨论如何将已经反编译后的文档重打包。\n刚才我们使用apktool d了安装包，现在我们将其重新打包起来。使用 apktool b \u0026lt;/path/to/dir\u0026gt; -o \u0026lt;output_apk_name\u0026gt;，这里 b 按照我的理解应该是和 d 对称，表示重新打包（当然这只是我的猜测和我的记忆方案），而 -o 等价于 --output，表示输出。还是一样的，如果你不熟悉，你可以使用 tldr 来看看这个命令如何使用。\n➜ Downloads tldr apktool apktool Reverse engineer APK files. More information: \u0026lt;https://ibotpeaches.github.io/Apktool/\u0026gt;. - Decode an APK file: apktool d path/to/file.apk - Build an APK file from a directory: apktool b path/to/directory - Install and store a framework: apktool if path/to/framework.apk ➜ Downloads 重新打包大概会出现下面的信息。\n➜ Downloads apktool b arcaea_5.10.1c -o ARCAEA_CHANGE.apk I: Using Apktool 2.9.3 I: Checking whether sources has changed... I: Smaling smali folder into classes.dex... I: Checking whether sources has changed... I: Smaling smali_classes2 folder into classes2.dex... I: Checking whether resources has changed... I: Building resources... I: Copying libs... (/lib) I: Copying libs... (/kotlin) I: Building apk file... I: Copying unknown files/dir... I: Built apk into: ARCAEA_CHANGE.apk ➜ Downloads 那么此时我们就拥有了一个新的 APK 文件，我们需要将其安装到安卓手机上。然而安卓手机在安装 apk 文件之前会检查文件的签名和包名。因此我们还需要将其签名（所幸本游戏没有加密、加壳、反调试和签名校验等等）。签名也有命令行工具，然而我们有更简单的方法。将我们生成的 apk 文件发送到你的设备上，在设备上下载一个 mt管理器，它可能会需要你注册登陆，但是那非常简单。在 mt 中找到你生成的 apk 文件。单击它，左下角功能，然后你就会看到一个签名的选项，点击签名然后使用默认签名方案签名之后就可以安装了。\n所说的改包名主要是为了共存。当然 mt 也提供了这个选项。当你想要在一个设备中安装两个一样的安装包，你就需要这个功能，它依然是傻瓜式的点击按钮，所以这里不再说明。至此你已经可以成功获取小贴图和更改图案了。\n这是我的一个特别喜欢草神的朋友改的，效果还不错。 ","date":"2 September 2024","externalUrl":null,"permalink":"/posts/arcaea_pics/","section":"Posts","summary":"","title":"Arcaea 小贴图","type":"posts"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]